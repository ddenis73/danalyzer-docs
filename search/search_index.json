{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"danalyzer This site provides documentation and tutorials on visualizing and analyzing polysomnography (PSG) data in MATLAB using the danalyzer What is the danalyzer? danalyzer is a toolbox for MATLAB for visualizing and analyzing sleep signals. The toolbox is primarily a graphical user interface (GUI) for visualizing and scoring PSG data. The motivation for writing it was to replace obsolete propriatary sleep scoring software, and to allow a common program for viewing data, sleep scoring etc. across labs using different systems. It is publically released in case it is something other might find useful. After installing, follow the Quickstart guide to get started. Installation 1. Download danalyzer The most up-to-date version can be downloaded here Click Code --> Download ZIP Move the zipped folder to somewhere on your computer where you can find it again Unzip the folder (on PC: right click and choose \"Extract All\", on Mac: double click the file) 2. Download EEGLAB danalyzer relies on EEGLAB functions to help with importing different types of data. If you already have EEGLAB downloaded you can skip this step Download EEGLAB here Unzip the eeglab.zip folder and move it somewhere on your computer where you can find it again 3. Add danalyzer to MATLAB Warning Make sure you have administrator privilages for running MATLAB, or else you may run into problems saving the updated MATLAB path. Open MATLAB In the \"Current Folder\" section of the MATLAB window navigate to the EEGLAB folder (you should be inside this folder and see a file called eeglab.m) In the \"Command Winow\" section of the MATLAB window type eeglab and press Enter It should pop up a blue/purple window To read EDF files : Download the biosig extension. Within the EEGLAB window, click File --> Manage EEGLAB Extensions --> Find and click on Biosig --> Click Install/Update --> Click Yes To read BrainVision files : Download the bva-io extension. Within the EEGLAB window, click File --> Manage EEGLAB Extensions --> Find and click on bva-io --> Click Install/Update --> Click Yes Navigate back to the main MATLAB window and click on the Home tab (at the top of the MATLAB window) Click on the \"Set Path\" icon. A new smaller window will pop up Click on \"Add with Subfolders\" Within the new window that pops up, navigate to the folder where you put the unzipped danalyzer-main folder. Then click on the danalyzer-main folder to select it, and press the \"Select folder\" button This should take you back to the \"Add path\" window. Click on \"Save\" To see if it worked, in the Command Window section of MATLAB type sleepDanalyzer and press Enter. If everything installed correctly, you should now see the main danalyzer window: License danalyzer is open source and released under the GNU General Public License v3.0 license and comes with absolutely no warrenty; without even the implied warrenty of merchantability or fitness for a particular purpose. danalyzer is intended for research purposes only. Any commercial or medical use of this software is prohibited. The authors accept to responsibility for its use in this manner.","title":"Home"},{"location":"#danalyzer","text":"This site provides documentation and tutorials on visualizing and analyzing polysomnography (PSG) data in MATLAB using the danalyzer","title":"danalyzer"},{"location":"#what-is-the-danalyzer","text":"danalyzer is a toolbox for MATLAB for visualizing and analyzing sleep signals. The toolbox is primarily a graphical user interface (GUI) for visualizing and scoring PSG data. The motivation for writing it was to replace obsolete propriatary sleep scoring software, and to allow a common program for viewing data, sleep scoring etc. across labs using different systems. It is publically released in case it is something other might find useful. After installing, follow the Quickstart guide to get started.","title":"What is the danalyzer?"},{"location":"#installation","text":"","title":"Installation"},{"location":"#1-download-danalyzer","text":"The most up-to-date version can be downloaded here Click Code --> Download ZIP Move the zipped folder to somewhere on your computer where you can find it again Unzip the folder (on PC: right click and choose \"Extract All\", on Mac: double click the file)","title":"1. Download danalyzer"},{"location":"#2-download-eeglab","text":"danalyzer relies on EEGLAB functions to help with importing different types of data. If you already have EEGLAB downloaded you can skip this step Download EEGLAB here Unzip the eeglab.zip folder and move it somewhere on your computer where you can find it again","title":"2. Download EEGLAB"},{"location":"#3-add-danalyzer-to-matlab","text":"Warning Make sure you have administrator privilages for running MATLAB, or else you may run into problems saving the updated MATLAB path. Open MATLAB In the \"Current Folder\" section of the MATLAB window navigate to the EEGLAB folder (you should be inside this folder and see a file called eeglab.m) In the \"Command Winow\" section of the MATLAB window type eeglab and press Enter It should pop up a blue/purple window To read EDF files : Download the biosig extension. Within the EEGLAB window, click File --> Manage EEGLAB Extensions --> Find and click on Biosig --> Click Install/Update --> Click Yes To read BrainVision files : Download the bva-io extension. Within the EEGLAB window, click File --> Manage EEGLAB Extensions --> Find and click on bva-io --> Click Install/Update --> Click Yes Navigate back to the main MATLAB window and click on the Home tab (at the top of the MATLAB window) Click on the \"Set Path\" icon. A new smaller window will pop up Click on \"Add with Subfolders\" Within the new window that pops up, navigate to the folder where you put the unzipped danalyzer-main folder. Then click on the danalyzer-main folder to select it, and press the \"Select folder\" button This should take you back to the \"Add path\" window. Click on \"Save\" To see if it worked, in the Command Window section of MATLAB type sleepDanalyzer and press Enter. If everything installed correctly, you should now see the main danalyzer window:","title":"3. Add danalyzer to MATLAB"},{"location":"#license","text":"danalyzer is open source and released under the GNU General Public License v3.0 license and comes with absolutely no warrenty; without even the implied warrenty of merchantability or fitness for a particular purpose. danalyzer is intended for research purposes only. Any commercial or medical use of this software is prohibited. The authors accept to responsibility for its use in this manner.","title":"License"},{"location":"danalyzer-file-formats/","text":"danalyzer file types Danalyzer has a strict format for how sleep scores, events, and artifact rejection information needs to be stored. The sections below detail in depth the structure of the key file types used by danalyzer. This section will be particularly useful for people trying to import data from another system/software package, and also for using danalyzer data files in downstream analysis. PSG file When data is loaded into danalyzer, it is stored as a psg structure. If you export/import PSG data as a .mat file, this is is the format which that data will follow: psg = struct with fields: data: [9\u00d76664000 single] hdr: [1\u00d71 struct] chans: [9\u00d71 struct] - data : The data itself, stored as channels x timepoints - hdr : A header file which contains the following fields: (srate: sampling rate in Hz, samples: The number of samples in the data, recStart: The start date/time of the original recording) - chans : Channel information (names, type, position), stored in the same way as EEGLAB Score file Files that are scored in danalyzer are written as .mat files with the variable name sleepstages . This variable is a struct with the following fields: sleepstages = struct with fields: stages: [1112\u00d71 double] hdr: [1\u00d71 struct] stages : This field contains the sleep stages themselves. Each row is an epoch, and the number corresponds to a certain sleep stage as follows (0 = Wake, 1-4 = N1-N4, 5 = REM, 6 = Movement, 7 = Unstaged) hdr : This field contains another structure containing additional information about the record. These fields are as follows: sleepstages.hdr ans = struct with fields: srate: 200 win: 30 recStart: '00:02:33.00' lOff: '00:09:07.85' lOn: '08:39:05.65' onsets: [1112\u00d71 double] stageTime: [1\u00d71112 double] notes: '' scorer: 'DD' srate : The sampling rate of the data (in Hz) win : The size of scored epochs (in seconds) recStart : The recording start time lOff : Lights off time lOn : Lights on time onsets : The onset time of each epoch in samples (epoch 1 = 1) stageTime : The onset time of each epoch in seconds (epoch 1 = 0) notes : Any notes made about the record during scoring scorer : The person who scored the record Events file Events files are tables (can be either a MATLAB table variable or a spreadsheet e.g. csv). The table must contain two columns. Column 1 is the clock time of the event, and column 2 is the event label. Note that danalyzer can also import BrainVision event files (.vmrk) that have their own organization structure. AR files Any artifact rejection that is carried out in sleepDanalyzer is saved into an ar struct, saved as a .mat file with the variable name ar . The structure contains the following fields: ar = struct with fields: badchans: [9\u00d71 double] badepochs: [1110\u00d71 logical] badsegments: [] badchans : An n x 1 vector where n = the number of channels in the data. If the channel has been marked as bad it is indicated as a 1 , otherwise it is zero. badepochs : An n x 1 vector where n = the number of epochs in the data. If the epoch has been marked as bad it is indicated as a 1, otherwise it is zero. badsegments : The bad segments field is populated when artifactual periods of data have been detected as continuous segments, rather than as an entire epoch. Bad segment arrays have an n x 9 size, where n = the total number of bad segments. Each column contains the following information (The epoch the segment was marked in, the sleep stage of that epoch, the type of marking (1, 2, 3), start time (s), end time (s), duration(s), start time (sample), end time (sample), duration (sample)). Importing data from other sources Danalyzer contains limited functionality for importing data in different formats to the ones described above. Such a scenario may arise where you want to load a file scored in a different software. To import externally scored files, first load the PSG file using File --> Open, but do not use the load sleep stages option here. Instead, load the PSG file by itself, and then navigate to File --> Import --> Sleep scores. You will then see a list of options for importing different types of sleep scores. Currently, danalyzer can automatically import files scored using Hume, Luna, and TWin. It can also attempt to load generic .txt and .csv files, where each row corresponds to a scored epoch of sleep. If using this option, a dialog box will appear asking you how each sleep stage is identified in your data (e.g. what is wake, N1, N2 etc coded as). If your external file does not correspond to any of the above options, then you will need to convert it manually to danalyzer format using a custom script. There are currently no way to import events and ar files that do not conform to the specifications described above.","title":"Danalyzer file formats"},{"location":"danalyzer-file-formats/#danalyzer-file-types","text":"Danalyzer has a strict format for how sleep scores, events, and artifact rejection information needs to be stored. The sections below detail in depth the structure of the key file types used by danalyzer. This section will be particularly useful for people trying to import data from another system/software package, and also for using danalyzer data files in downstream analysis.","title":"danalyzer file types"},{"location":"danalyzer-file-formats/#psg-file","text":"When data is loaded into danalyzer, it is stored as a psg structure. If you export/import PSG data as a .mat file, this is is the format which that data will follow: psg = struct with fields: data: [9\u00d76664000 single] hdr: [1\u00d71 struct] chans: [9\u00d71 struct] - data : The data itself, stored as channels x timepoints - hdr : A header file which contains the following fields: (srate: sampling rate in Hz, samples: The number of samples in the data, recStart: The start date/time of the original recording) - chans : Channel information (names, type, position), stored in the same way as EEGLAB","title":"PSG file"},{"location":"danalyzer-file-formats/#score-file","text":"Files that are scored in danalyzer are written as .mat files with the variable name sleepstages . This variable is a struct with the following fields: sleepstages = struct with fields: stages: [1112\u00d71 double] hdr: [1\u00d71 struct] stages : This field contains the sleep stages themselves. Each row is an epoch, and the number corresponds to a certain sleep stage as follows (0 = Wake, 1-4 = N1-N4, 5 = REM, 6 = Movement, 7 = Unstaged) hdr : This field contains another structure containing additional information about the record. These fields are as follows: sleepstages.hdr ans = struct with fields: srate: 200 win: 30 recStart: '00:02:33.00' lOff: '00:09:07.85' lOn: '08:39:05.65' onsets: [1112\u00d71 double] stageTime: [1\u00d71112 double] notes: '' scorer: 'DD' srate : The sampling rate of the data (in Hz) win : The size of scored epochs (in seconds) recStart : The recording start time lOff : Lights off time lOn : Lights on time onsets : The onset time of each epoch in samples (epoch 1 = 1) stageTime : The onset time of each epoch in seconds (epoch 1 = 0) notes : Any notes made about the record during scoring scorer : The person who scored the record","title":"Score file"},{"location":"danalyzer-file-formats/#events-file","text":"Events files are tables (can be either a MATLAB table variable or a spreadsheet e.g. csv). The table must contain two columns. Column 1 is the clock time of the event, and column 2 is the event label. Note that danalyzer can also import BrainVision event files (.vmrk) that have their own organization structure.","title":"Events file"},{"location":"danalyzer-file-formats/#ar-files","text":"Any artifact rejection that is carried out in sleepDanalyzer is saved into an ar struct, saved as a .mat file with the variable name ar . The structure contains the following fields: ar = struct with fields: badchans: [9\u00d71 double] badepochs: [1110\u00d71 logical] badsegments: [] badchans : An n x 1 vector where n = the number of channels in the data. If the channel has been marked as bad it is indicated as a 1 , otherwise it is zero. badepochs : An n x 1 vector where n = the number of epochs in the data. If the epoch has been marked as bad it is indicated as a 1, otherwise it is zero. badsegments : The bad segments field is populated when artifactual periods of data have been detected as continuous segments, rather than as an entire epoch. Bad segment arrays have an n x 9 size, where n = the total number of bad segments. Each column contains the following information (The epoch the segment was marked in, the sleep stage of that epoch, the type of marking (1, 2, 3), start time (s), end time (s), duration(s), start time (sample), end time (sample), duration (sample)).","title":"AR files"},{"location":"danalyzer-file-formats/#importing-data-from-other-sources","text":"Danalyzer contains limited functionality for importing data in different formats to the ones described above. Such a scenario may arise where you want to load a file scored in a different software. To import externally scored files, first load the PSG file using File --> Open, but do not use the load sleep stages option here. Instead, load the PSG file by itself, and then navigate to File --> Import --> Sleep scores. You will then see a list of options for importing different types of sleep scores. Currently, danalyzer can automatically import files scored using Hume, Luna, and TWin. It can also attempt to load generic .txt and .csv files, where each row corresponds to a scored epoch of sleep. If using this option, a dialog box will appear asking you how each sleep stage is identified in your data (e.g. what is wake, N1, N2 etc coded as). If your external file does not correspond to any of the above options, then you will need to convert it manually to danalyzer format using a custom script. There are currently no way to import events and ar files that do not conform to the specifications described above.","title":"Importing data from other sources"},{"location":"gui-data-browser/","text":"Data browsing Before you can interact with the GUI, you must click in an empty gray area of the GUI . Navigate between epochs by pressing the left or right arrow key (or by pressing the < or > buttons). You can jump forwards or backwards in chunks of 10 epochs by clicking the >> or << buttons. The current epoch number is displayed in the bottom left. You can type any epoch number into this box to immediately jump to it. You can also move to a specific epoch by clicking on the corresponding space in the hypnogram window at the top of the GUI. The current scale of the data is indicated in the box next to the montage list (default is 150). The scale can be adjusted by typing a new scale value into the box, or using the +/- buttons to increase or decrease the scale in chunks of 25. Tip Scale units in danalyzer are essentially aribtary. danalyzer assumes the data are stored in microvolts, but this may not always be the case. If your data are all flat lines, one reason could be that the data are not microvolts.","title":"Data browsing"},{"location":"gui-data-browser/#data-browsing","text":"Before you can interact with the GUI, you must click in an empty gray area of the GUI . Navigate between epochs by pressing the left or right arrow key (or by pressing the < or > buttons). You can jump forwards or backwards in chunks of 10 epochs by clicking the >> or << buttons. The current epoch number is displayed in the bottom left. You can type any epoch number into this box to immediately jump to it. You can also move to a specific epoch by clicking on the corresponding space in the hypnogram window at the top of the GUI. The current scale of the data is indicated in the box next to the montage list (default is 150). The scale can be adjusted by typing a new scale value into the box, or using the +/- buttons to increase or decrease the scale in chunks of 25. Tip Scale units in danalyzer are essentially aribtary. danalyzer assumes the data are stored in microvolts, but this may not always be the case. If your data are all flat lines, one reason could be that the data are not microvolts.","title":"Data browsing"},{"location":"gui-file-formats/","text":"danalyzer file types Danalyzer has a strict format for how sleep scores, events, and artifact rejection information needs to be stored. The sections below detail in depth the structure of the key file types used by danalyzer. This section will be particularly useful for people trying to import data from another system/software package, and also for using danalyzer data files in downstream analysis. PSG file When data is loaded into danalyzer, it is stored as a psg structure. If you export/import PSG data as a .mat file, this is is the format which that data will follow: psg = struct with fields: data: [9\u00d76664000 single] hdr: [1\u00d71 struct] chans: [9\u00d71 struct] - data : The data itself, stored as channels x timepoints - hdr : A header file which contains the following fields: (srate: sampling rate in Hz, samples: The number of samples in the data, recStart: The start date/time of the original recording) - chans : Channel information (names, type, position), stored in the same way as EEGLAB (e.g. EEG.chanlocs) Score file Files that are scored in danalyzer are saved as .mat files with the variable name sleepstages . This variable is a struct with the following fields: sleepstages = struct with fields: stages: [1112\u00d71 double] hdr: [1\u00d71 struct] stages : This field contains the sleep stages themselves. Each row is an epoch, and the number corresponds to a certain sleep stage as follows (0 = Wake, 1-4 = N1-N4, 5 = REM, 6 = Movement, 7 = Unstaged) hdr : This field contains another structure containing additional information about the score file. These fields are as follows: sleepstages.hdr ans = struct with fields: srate: 200 win: 30 recStart: '00:02:33.00' lOff: '00:09:07.85' lOn: '08:39:05.65' onsets: [1112\u00d71 double] stageTime: [1\u00d71112 double] notes: '' scorer: 'DD' srate : The sampling rate of the data (in Hz) win : The size of scored epochs (in seconds) recStart : The recording start time lOff : Lights off time lOn : Lights on time onsets : The onset time of each epoch in samples (epoch 1 = 1) stageTime : The onset time of each epoch in seconds (epoch 1 = 0) notes : Any notes made about the record during scoring scorer : The person who scored the record Events file Events files are tables (can be either a MATLAB table variable or a spreadsheet e.g. csv). The table must contain two columns. Column 1 is the clock time of the event, and column 2 is the event label. Note that danalyzer can also import BrainVision event files (.vmrk) that have their own organization structure. AR files Any artifact rejection that is carried out in sleepDanalyzer is saved into an ar struct, saved as a .mat file with the variable name ar . The structure contains the following fields: ar = struct with fields: badchans: [9\u00d71 double] badepochs: [1110\u00d71 logical] badsegments: [] badchans : An n x 1 vector where n = the number of channels in the data. If the channel has been marked as bad it is indicated as a 1 , otherwise it is zero. badepochs : An n x 1 vector where n = the number of epochs in the data. If the epoch has been marked as bad it is indicated as a 1, otherwise it is zero. badsegments : The bad segments field is populated when artifactual periods of data have been detected as continuous segments, rather than as an entire epoch. Bad segment arrays have an n x 9 size, where n = the total number of bad segments. Each column contains the following information (The epoch the segment was marked in, the sleep stage of that epoch, the type of marking (1, 2, 3), start time (s), end time (s), duration(s), start time (sample), end time (sample), duration (sample)). Importing data from other sources Danalyzer contains limited functionality for importing data in different formats to the ones described above. Such a scenario may arise where you want to load a file scored in a different software. To import externally scored files, first load the PSG file using File --> Open, but do not use the load sleep stages option here. Instead, load the PSG file by itself, and then navigate to File --> Import --> Sleep scores. You will then see a list of options for importing different types of sleep scores. Currently, danalyzer can automatically import files scored using Hume, Luna, and TWin. It can also attempt to load generic .txt and .csv files, where each row corresponds to a scored epoch of sleep. If using this option, a dialog box will appear asking you how each sleep stage is identified in your data (e.g. what is wake, N1, N2 etc coded as). If your external file does not correspond to any of the above options, then you will need to convert it manually to danalyzer format using a custom script. There are currently no way to import events and ar files that do not conform to the specifications described above.","title":"File format information"},{"location":"gui-file-formats/#danalyzer-file-types","text":"Danalyzer has a strict format for how sleep scores, events, and artifact rejection information needs to be stored. The sections below detail in depth the structure of the key file types used by danalyzer. This section will be particularly useful for people trying to import data from another system/software package, and also for using danalyzer data files in downstream analysis.","title":"danalyzer file types"},{"location":"gui-file-formats/#psg-file","text":"When data is loaded into danalyzer, it is stored as a psg structure. If you export/import PSG data as a .mat file, this is is the format which that data will follow: psg = struct with fields: data: [9\u00d76664000 single] hdr: [1\u00d71 struct] chans: [9\u00d71 struct] - data : The data itself, stored as channels x timepoints - hdr : A header file which contains the following fields: (srate: sampling rate in Hz, samples: The number of samples in the data, recStart: The start date/time of the original recording) - chans : Channel information (names, type, position), stored in the same way as EEGLAB (e.g. EEG.chanlocs)","title":"PSG file"},{"location":"gui-file-formats/#score-file","text":"Files that are scored in danalyzer are saved as .mat files with the variable name sleepstages . This variable is a struct with the following fields: sleepstages = struct with fields: stages: [1112\u00d71 double] hdr: [1\u00d71 struct] stages : This field contains the sleep stages themselves. Each row is an epoch, and the number corresponds to a certain sleep stage as follows (0 = Wake, 1-4 = N1-N4, 5 = REM, 6 = Movement, 7 = Unstaged) hdr : This field contains another structure containing additional information about the score file. These fields are as follows: sleepstages.hdr ans = struct with fields: srate: 200 win: 30 recStart: '00:02:33.00' lOff: '00:09:07.85' lOn: '08:39:05.65' onsets: [1112\u00d71 double] stageTime: [1\u00d71112 double] notes: '' scorer: 'DD' srate : The sampling rate of the data (in Hz) win : The size of scored epochs (in seconds) recStart : The recording start time lOff : Lights off time lOn : Lights on time onsets : The onset time of each epoch in samples (epoch 1 = 1) stageTime : The onset time of each epoch in seconds (epoch 1 = 0) notes : Any notes made about the record during scoring scorer : The person who scored the record","title":"Score file"},{"location":"gui-file-formats/#events-file","text":"Events files are tables (can be either a MATLAB table variable or a spreadsheet e.g. csv). The table must contain two columns. Column 1 is the clock time of the event, and column 2 is the event label. Note that danalyzer can also import BrainVision event files (.vmrk) that have their own organization structure.","title":"Events file"},{"location":"gui-file-formats/#ar-files","text":"Any artifact rejection that is carried out in sleepDanalyzer is saved into an ar struct, saved as a .mat file with the variable name ar . The structure contains the following fields: ar = struct with fields: badchans: [9\u00d71 double] badepochs: [1110\u00d71 logical] badsegments: [] badchans : An n x 1 vector where n = the number of channels in the data. If the channel has been marked as bad it is indicated as a 1 , otherwise it is zero. badepochs : An n x 1 vector where n = the number of epochs in the data. If the epoch has been marked as bad it is indicated as a 1, otherwise it is zero. badsegments : The bad segments field is populated when artifactual periods of data have been detected as continuous segments, rather than as an entire epoch. Bad segment arrays have an n x 9 size, where n = the total number of bad segments. Each column contains the following information (The epoch the segment was marked in, the sleep stage of that epoch, the type of marking (1, 2, 3), start time (s), end time (s), duration(s), start time (sample), end time (sample), duration (sample)).","title":"AR files"},{"location":"gui-file-formats/#importing-data-from-other-sources","text":"Danalyzer contains limited functionality for importing data in different formats to the ones described above. Such a scenario may arise where you want to load a file scored in a different software. To import externally scored files, first load the PSG file using File --> Open, but do not use the load sleep stages option here. Instead, load the PSG file by itself, and then navigate to File --> Import --> Sleep scores. You will then see a list of options for importing different types of sleep scores. Currently, danalyzer can automatically import files scored using Hume, Luna, and TWin. It can also attempt to load generic .txt and .csv files, where each row corresponds to a scored epoch of sleep. If using this option, a dialog box will appear asking you how each sleep stage is identified in your data (e.g. what is wake, N1, N2 etc coded as). If your external file does not correspond to any of the above options, then you will need to convert it manually to danalyzer format using a custom script. There are currently no way to import events and ar files that do not conform to the specifications described above.","title":"Importing data from other sources"},{"location":"gui-load-data/","text":"Loading data To load data into danalyzer, navigate to File \u2192 Load data or press CTRL + O (CMD + O on a Mac). This will bring up a window giving you the options to load various types of data. Either type the directory or use the push buttons to navigate to the file you wish to load. sleepDanalyzer can load the following types of file: Load dataset Load in an EEG/PSG file. Currently, danalyzer can load data in any of the following formats: - .edf - .vhdr (BrainVision header file) - .set (EEGLAB native format) For any of these to work, EEGLAB must be installed. In addition, the Biosig extension for EEGLAB is required for .edf files, and the bva-io extenstion is required for .vhdr files. danalyzer can also load data stored as a .mat file, providing that the .mat is a formatted psg structure. Read more about file formats here. Load sleep stages Load an existing score file that has been scored using danalyzer. Learn more about danalyzer score file format here, and information on how to export score files in different formats here. Load events An events file, sometimes called a notations or annotations file. This file contains key events that happened during the recording (e.g. lights off/on times, biocalibrations etc.). Event files are tables (can either be a MATLAB table or spreadsheet (.xlsx or .csv)). The table must contain two columns. Column 1 is the clock time of the event, and column 2 is the event label. Note that danalyzer can also import BrainVision event files (.vmrk) that have their own organization structure. Load ar Load an existing artifact rejection file that has been created using danalyzer. Read here for information on the format of danalyzer ar files. After selecting the files you wish to load, click OK to read in the data (this may take a while depending on the size of the data file). When all of the data has been loaded, a new window will appear. Carefully review this window before you start scoring. The recording start time, lights off time, and lights on time fields will be automatically filled if a correctly formatted events file was loaded. If you don\u2019t have an events file, the recording start time will be pulled from the dataset, and lights off and lights on time can be entered manually. All times should be entered in the format: hh:mm:ss.sss . If lights off/on times are not specified, fanalyzer will assume that lights off was at the start of the dataset, and lights on was at the end of the recording . The epoch length field specifies the epoch epoch size you wish to use for scoring, and defaults to 30 seconds. You can produce a spectogram on a specific channel by entering the name of the channel in the spectogram field. Use the scorer initial field to identify the individual who scored the record. When everything is entered correctly, click Confirm to pull the data into the GUI. If you have asked for a spectogram, it will take some time to complete. If everything went well, your data will appear something like this:","title":"Loading data"},{"location":"gui-load-data/#loading-data","text":"To load data into danalyzer, navigate to File \u2192 Load data or press CTRL + O (CMD + O on a Mac). This will bring up a window giving you the options to load various types of data. Either type the directory or use the push buttons to navigate to the file you wish to load. sleepDanalyzer can load the following types of file:","title":"Loading data"},{"location":"gui-load-data/#load-dataset","text":"Load in an EEG/PSG file. Currently, danalyzer can load data in any of the following formats: - .edf - .vhdr (BrainVision header file) - .set (EEGLAB native format) For any of these to work, EEGLAB must be installed. In addition, the Biosig extension for EEGLAB is required for .edf files, and the bva-io extenstion is required for .vhdr files. danalyzer can also load data stored as a .mat file, providing that the .mat is a formatted psg structure. Read more about file formats here.","title":"Load dataset"},{"location":"gui-load-data/#load-sleep-stages","text":"Load an existing score file that has been scored using danalyzer. Learn more about danalyzer score file format here, and information on how to export score files in different formats here.","title":"Load sleep stages"},{"location":"gui-load-data/#load-events","text":"An events file, sometimes called a notations or annotations file. This file contains key events that happened during the recording (e.g. lights off/on times, biocalibrations etc.). Event files are tables (can either be a MATLAB table or spreadsheet (.xlsx or .csv)). The table must contain two columns. Column 1 is the clock time of the event, and column 2 is the event label. Note that danalyzer can also import BrainVision event files (.vmrk) that have their own organization structure.","title":"Load events"},{"location":"gui-load-data/#load-ar","text":"Load an existing artifact rejection file that has been created using danalyzer. Read here for information on the format of danalyzer ar files. After selecting the files you wish to load, click OK to read in the data (this may take a while depending on the size of the data file). When all of the data has been loaded, a new window will appear. Carefully review this window before you start scoring. The recording start time, lights off time, and lights on time fields will be automatically filled if a correctly formatted events file was loaded. If you don\u2019t have an events file, the recording start time will be pulled from the dataset, and lights off and lights on time can be entered manually. All times should be entered in the format: hh:mm:ss.sss . If lights off/on times are not specified, fanalyzer will assume that lights off was at the start of the dataset, and lights on was at the end of the recording . The epoch length field specifies the epoch epoch size you wish to use for scoring, and defaults to 30 seconds. You can produce a spectogram on a specific channel by entering the name of the channel in the spectogram field. Use the scorer initial field to identify the individual who scored the record. When everything is entered correctly, click Confirm to pull the data into the GUI. If you have asked for a spectogram, it will take some time to complete. If everything went well, your data will appear something like this:","title":"Load ar"},{"location":"gui-montage/","text":"Montages It is likely that you will want to change some details about how the data look for the purposes of sleep scoring. All of these alternations are commanded through a montage file, a MATLAB script that controls how the data are presented. To select a montage, click on the montage list and select which montage you want to use. The display will update accordingly: In this example, applying the montag added scale lines around channel F3. It also re-colored EOG and EMG channels blue and red respectively. Editing a montage You can edit a montage on-the-fly by navigating to Montage \u2192 Edit montage (or by pressing the m key), which brings up a dialog window. You can specify any of the following changes: Scale : Integer specifying a new scale for all channels Scale channel : The channel that you wish the scale lines to be displayed around. Leaving this blank will remove scale lines entirely Scale values : A value indicating where to place each scale line Scale color : A MATLAB RGB triplet indicating the color of the scale lines Hide channels : A list of channels you want to hide (i.e. remove from the display) Channel order : The order in which the channels are displayed. If you specify channels to hide, ensure that they are not listed in the channel order. EEG color : The color of all EEG channels EOG color : The color of all EOG channels EMG color : The color of all EMG channels ECG color : The color of all ECG channels Other color : The color of all other channels Click OK to adopt these new settings. You can always revert back to a predefined montage by selecting it from the montage list. You can also clear the montage entirely by navigating to Montage \u2192 Clear montage When you are happy with your montage settings, we can begin browsing the data and sleep scoring!","title":"Montage creation"},{"location":"gui-montage/#montages","text":"It is likely that you will want to change some details about how the data look for the purposes of sleep scoring. All of these alternations are commanded through a montage file, a MATLAB script that controls how the data are presented. To select a montage, click on the montage list and select which montage you want to use. The display will update accordingly: In this example, applying the montag added scale lines around channel F3. It also re-colored EOG and EMG channels blue and red respectively.","title":"Montages"},{"location":"gui-montage/#editing-a-montage","text":"You can edit a montage on-the-fly by navigating to Montage \u2192 Edit montage (or by pressing the m key), which brings up a dialog window. You can specify any of the following changes: Scale : Integer specifying a new scale for all channels Scale channel : The channel that you wish the scale lines to be displayed around. Leaving this blank will remove scale lines entirely Scale values : A value indicating where to place each scale line Scale color : A MATLAB RGB triplet indicating the color of the scale lines Hide channels : A list of channels you want to hide (i.e. remove from the display) Channel order : The order in which the channels are displayed. If you specify channels to hide, ensure that they are not listed in the channel order. EEG color : The color of all EEG channels EOG color : The color of all EOG channels EMG color : The color of all EMG channels ECG color : The color of all ECG channels Other color : The color of all other channels Click OK to adopt these new settings. You can always revert back to a predefined montage by selecting it from the montage list. You can also clear the montage entirely by navigating to Montage \u2192 Clear montage When you are happy with your montage settings, we can begin browsing the data and sleep scoring!","title":"Editing a montage"},{"location":"gui-reliability/","text":"Scorer reliability Inter-rater reliability of two sleep scorers can be calculate within the GUI. Both scorers must have scored the record independently in danalyzer, and each saved a score file. Typically there will be the scorer file of the new scorer (the trainee) whose sleep staging needs to be compared to a expert scorer. To begin, load the datafile and the score file of the trainee into danalyzer. With these loaded, we are then going to overlay the master score file, and calculate reliability between the two. To overlay the master file, go File --> Import --> Sleep scores --> danalyzer. Navigate to the master score file and click Open. Then a dialog box will open asking if you want to Overlay the two score files, or Replace the existing score file with the new one. Make sure to click the Overlay option. You should now see the two hypnograms overlaid on top of each other in the hypnogram window. In this view, you can jump to epochs where the two score files don't align to discuss discrepencies. You caclulate reliability, navigate to Sleep Statistics --> Compare scorers. Enter a name for the reliability file, and click Save. A reliability report will automatically appear, which displays the two hypnograms overlaid on each other, as well as an agreement table, percent agreement for each sleep stage, and an overall kappa rating. Tip Scorer reliability can be performed using the function fun_scorer_reliability in a MATLAB script","title":"Sleep scorer reliability"},{"location":"gui-reliability/#scorer-reliability","text":"Inter-rater reliability of two sleep scorers can be calculate within the GUI. Both scorers must have scored the record independently in danalyzer, and each saved a score file. Typically there will be the scorer file of the new scorer (the trainee) whose sleep staging needs to be compared to a expert scorer. To begin, load the datafile and the score file of the trainee into danalyzer. With these loaded, we are then going to overlay the master score file, and calculate reliability between the two. To overlay the master file, go File --> Import --> Sleep scores --> danalyzer. Navigate to the master score file and click Open. Then a dialog box will open asking if you want to Overlay the two score files, or Replace the existing score file with the new one. Make sure to click the Overlay option. You should now see the two hypnograms overlaid on top of each other in the hypnogram window. In this view, you can jump to epochs where the two score files don't align to discuss discrepencies. You caclulate reliability, navigate to Sleep Statistics --> Compare scorers. Enter a name for the reliability file, and click Save. A reliability report will automatically appear, which displays the two hypnograms overlaid on each other, as well as an agreement table, percent agreement for each sleep stage, and an overall kappa rating. Tip Scorer reliability can be performed using the function fun_scorer_reliability in a MATLAB script","title":"Scorer reliability"},{"location":"gui-save-scores/","text":"Saving sleep scores When you have finished scoring a record, you will want to save the sleep scores. To save data, navigate to File \u2192 Save data to bring up the Save dialogue. As with loading data, sleepDanalyzer can also save many different kinds of data. To save sleep scores, type the directory or click the push button next to \u201cSave sleep scores\u201d (second row). If you use the push button, this will let you select a destination and name for the sleep scores. Navigate to the folder you wish to save and give the file a name, and then click save ( NOTE: YOUR DATA HAVE NOT SAVED YET ). Then, in sleepDanalyzer, click the green Save button to actually save your data. To verify that the scores have been saved, check that a .mat file has indeed appeared in the folder you specified. There is nothing worse than not correctly saving your data after spending all that time sleep scoring! You should now be at a point where you can load in a dataset, apply a basic montage, and be comfortable with using the sleepDanalyzer to sleep score.","title":"Saving sleep scores"},{"location":"gui-save-scores/#saving-sleep-scores","text":"When you have finished scoring a record, you will want to save the sleep scores. To save data, navigate to File \u2192 Save data to bring up the Save dialogue. As with loading data, sleepDanalyzer can also save many different kinds of data. To save sleep scores, type the directory or click the push button next to \u201cSave sleep scores\u201d (second row). If you use the push button, this will let you select a destination and name for the sleep scores. Navigate to the folder you wish to save and give the file a name, and then click save ( NOTE: YOUR DATA HAVE NOT SAVED YET ). Then, in sleepDanalyzer, click the green Save button to actually save your data. To verify that the scores have been saved, check that a .mat file has indeed appeared in the folder you specified. There is nothing worse than not correctly saving your data after spending all that time sleep scoring! You should now be at a point where you can load in a dataset, apply a basic montage, and be comfortable with using the sleepDanalyzer to sleep score.","title":"Saving sleep scores"},{"location":"gui-sleep-scoring/","text":"Sleep scoring Sleep scoring is incredibly straightforward. Score an epoch simply by pressing the corresponding button on the keyboard: 0 = Wake 1 = N1 2 = N2 3 = N3 4 = N4 5 = REM 6 = Movement After scoring an epoch, the display will automatically advance. If you wish to unstage an epoch, press the period (.) key. As you score, you will see that the hypnogram also starts to be created. If you want to make any notes about the record that you are scoring, press the n key to bring up the Notes window. Here you can record any details about the record, and these notes will be saved alongside the score file.","title":"Sleep scoring"},{"location":"gui-sleep-scoring/#sleep-scoring","text":"Sleep scoring is incredibly straightforward. Score an epoch simply by pressing the corresponding button on the keyboard: 0 = Wake 1 = N1 2 = N2 3 = N3 4 = N4 5 = REM 6 = Movement After scoring an epoch, the display will automatically advance. If you wish to unstage an epoch, press the period (.) key. As you score, you will see that the hypnogram also starts to be created. If you want to make any notes about the record that you are scoring, press the n key to bring up the Notes window. Here you can record any details about the record, and these notes will be saved alongside the score file.","title":"Sleep scoring"},{"location":"gui-sleep-statistics/","text":"Sleep statistics Sleep statistics can be calculated within the GUI. This will save the data to a file, and will also automatically produce a basic sleep report in .html format. See an example report here . Tip In general, it is better to calculate sleep statistics by calling the fun_sleep_statistics command as part of a batch MATLAB script to process multiple score files at once When you get to the end of a record, click on Sleep Statistics --> Calculate sleep statistics. This will open up a dialogue box where you can set the rule for determining sleep onset. If you want to add a spectogram to the report, you can enter the name of a channel you wish to use. Choose where to save the data by either typing in a directory or pressing the push button next to Save location. If you use the push button, this will let you select a destination and name for the sleep statistics file. Navigate to the folder you wish to save to, and give the file a name. Then click save. Then, in the Sleep statistics dialogue, click the green Save button to produce the report and save the sleep statistics. Bug When creating the spectogram, if the last epoch of data is very short (shorter than 5 seconds), danalyzer will throw an error. This is because the length of the data in the final epoch is shorter than the length of the Hamming window used to create the spectogram. This bug will be fixed in a later version. For now, spectograms can be made using a MATLAB script.","title":"Sleep statistics"},{"location":"gui-sleep-statistics/#sleep-statistics","text":"Sleep statistics can be calculated within the GUI. This will save the data to a file, and will also automatically produce a basic sleep report in .html format. See an example report here . Tip In general, it is better to calculate sleep statistics by calling the fun_sleep_statistics command as part of a batch MATLAB script to process multiple score files at once When you get to the end of a record, click on Sleep Statistics --> Calculate sleep statistics. This will open up a dialogue box where you can set the rule for determining sleep onset. If you want to add a spectogram to the report, you can enter the name of a channel you wish to use. Choose where to save the data by either typing in a directory or pressing the push button next to Save location. If you use the push button, this will let you select a destination and name for the sleep statistics file. Navigate to the folder you wish to save to, and give the file a name. Then click save. Then, in the Sleep statistics dialogue, click the green Save button to produce the report and save the sleep statistics. Bug When creating the spectogram, if the last epoch of data is very short (shorter than 5 seconds), danalyzer will throw an error. This is because the length of the data in the final epoch is shorter than the length of the Hamming window used to create the spectogram. This bug will be fixed in a later version. For now, spectograms can be made using a MATLAB script.","title":"Sleep statistics"},{"location":"gui-tutorial/","text":"danalyzer GUI quickstart This brief tutorial will show you how to quickly start scoring data. This assumes you have a file ready to be sleep scored. Open danalyzer With sleepDanalyzer downloaded and added to the MATLAB path, start the GUI by typing: sleepDanalyzer into the MATLAB command window. This will print some text to the command window. If everything has been installed correctly, you should see something like this: Starting sleepDanalyzer version: 0.9.0 NOTE: This is a beta version of sleepDanalyzer!!! Features still in development Welcome to sleepDanalyzer! The GUI relies on a number of EEGLAB functions to help import data of different types. If sleepDanalyzer cannot find these import functions, you will get a warning e.g.: Warning: BIOSIG extension for EEGLAB not found. Will not be able to import .edf files If you get a warning like this, check your EEGLAB installation and ensure that 1) EEGLAB is on the MATLAB path, and 2) the relevant EEGlAB extensions are installed (BIOSIG extension required for .edf files, and BVA-IO extension required for BrainVision files). If all has gone well, a blank GUI will have opened. Load data To load data into danalyzer, navigate to File --> Load data or press CTRL + O (CMD + O on a Mac). In the window that opens, we are going to Load dataset . Either type the directory or use the push butons to navigate to the file that you wish to load. After selecting the file, click OK to read in the data (this may take a while depending on the size of the data file). When the data is loaded, a new window will appear. Carefully review this window before you start scoring. The recording start time is pulled from the dataset. If you have them, enter the lights off and on time. All times should be entered in the format: hh:mm:ss.sss. If lights off/on times are not specified, danalyzer will assume that lights off was at the start of recording, and lights on was at the end of the recording . Keep the epoch length field at the default 30 seconds. When everything is entered correctly, click Confirm to pull the data into the GUI. If everything went well, your data will appear something like this: Apply a montage You will likely want to change some details about how the data look for the purposes of sleep scoring (for example, adding a scale line). All of these alterations are controlled though a montage file, a MATLAB script that controls how the data are presented. To select a montage, click on the montage list and select which montage you want to use. When a particular montage is selected, the display will update accordingly: In this example, applying the montage added scale lines around channel F3. It also re-colored EOG and EMG channels blue and red respectively. Editing a montage You can edit the motnage on-the-fly by navigating to Montage --> Edit montage (or by pressing the m key), which brings up a dialog window. You can specify any of the following changes: Scale : Integer specifying a new scale for all channels Scale channel : The channel that you wish the scale lines to be displayed around. Leaving this blank will remove the scale lines entirely Scale values : A value indicating where to place each scale line Scale color : A MATLAB RGB triplety indicating the color of the scale lines Hide channels : A list of channels you want to hide (i.e. remove from the display) Channel order : The order in which the channels are displayed. If you specify channels to hide, ensure that they are not listed in the channel order EEG color : The color of all EEG channels EOG color : The color of all EOG channels EMG color : The color of all EMG channels ECG color : The color of all ECG channels Other color : The color of all other channels Click OK to adopt these new settings. You can always revert back to a predefined montage by selecting it from the montage list. You can also clear the montage entirely by navigating to Montage --> Clear montage. Tip Rather than making on-the-fly changes each time, the best approach is to create a new montage file and add it to the list of available montages. See the Montage creation guide for full details. When you are happy with your montage settings, we can begin browsing the data and start sleep scoring! Data browsing and sleep scoring Before you can interact with the GUI, you must click in an empty gray area of the GUI . Navigate between epochs by pressing the left or right arrow key. You can jump forwards or backwards in chunks of 10 epochs by clicking the >> or << buttons. The current epoch number is displayed in the bottom left. You can type any epoch number into this box to immediately jump to it. You can also move to a specific epoch by clicking on the corresponding space in the hypnogram window at the top of the GUI. The current scale of the data is indicated in the box next to the montage list (default is 150). The scale can be adjusted by typing a new scale value into the box, or using the +/- buttons to increase or decrease the scale in chunks of 25. Tip Scale units in danalyzer are essentially aribtary. danalyzer assumes the data are stored in microvolts, but this may not always be the case. If your data are all flat lines, one reason could be that the data are not microvolts. Sleep scoring is incredibly straightforward. Score an epoch simply by pressing the corresponding button on the keyboard: 0 = Wake 1 = N1 2 = N2 3 = N3 4 = N4 5 = REM 6 = Movement After scoring an epoch, the display will automatically advance. If you wish to unstage an epoch, press the period (.) key. As you score, you will see that the hypnogram also starts to be created. If you want to make any notes about the record that you are scoring, press the n key to bring up the Notes window. Here you can record any details about the record, and these notes will be saved alongside the score file. Saving sleep scores When you have finished scoring a record, you will want to save the sleep scores. To save data, navigate to File --> Savd data or press CTRL/CMD + S to bring up the Save dialogue. As with loading data, danalyzer can also save many different kinds of data. To save sleep scores, type the directory or click the push button next to \"Save sleep scores\" (second row). If you use the push button, this will let you select a destination and name for the sleep scores. Navigate to the folder you wish to save to, and give the file a name. Then click save NOTE: YOUR DATA HAVE NOT SAVED YET . Then, in danalyzer, click the freen Save button to actually save your data. To verify that the scores have been saved, check that a .mat file has indeed appeared in the folder that you specified. There is nothing worse than not correctly saving your data after spending all that time sleep scoring! Tip Full documentation about the format of danalyzer files can be found here. If you need to import/export to other types of file, see here. You should now be at a point where you know how to load a dataset, apply a montage, and be comfortable with using danalyzer to sleep score. To learn more about the full functionality, see the relevant pages in the Reference tab on the sidebar. Happy sleep scoring!","title":"Quickstart"},{"location":"gui-tutorial/#danalyzer-gui-quickstart","text":"This brief tutorial will show you how to quickly start scoring data. This assumes you have a file ready to be sleep scored.","title":"danalyzer GUI quickstart"},{"location":"gui-tutorial/#open-danalyzer","text":"With sleepDanalyzer downloaded and added to the MATLAB path, start the GUI by typing: sleepDanalyzer into the MATLAB command window. This will print some text to the command window. If everything has been installed correctly, you should see something like this: Starting sleepDanalyzer version: 0.9.0 NOTE: This is a beta version of sleepDanalyzer!!! Features still in development Welcome to sleepDanalyzer! The GUI relies on a number of EEGLAB functions to help import data of different types. If sleepDanalyzer cannot find these import functions, you will get a warning e.g.: Warning: BIOSIG extension for EEGLAB not found. Will not be able to import .edf files If you get a warning like this, check your EEGLAB installation and ensure that 1) EEGLAB is on the MATLAB path, and 2) the relevant EEGlAB extensions are installed (BIOSIG extension required for .edf files, and BVA-IO extension required for BrainVision files). If all has gone well, a blank GUI will have opened.","title":"Open danalyzer"},{"location":"gui-tutorial/#load-data","text":"To load data into danalyzer, navigate to File --> Load data or press CTRL + O (CMD + O on a Mac). In the window that opens, we are going to Load dataset . Either type the directory or use the push butons to navigate to the file that you wish to load. After selecting the file, click OK to read in the data (this may take a while depending on the size of the data file). When the data is loaded, a new window will appear. Carefully review this window before you start scoring. The recording start time is pulled from the dataset. If you have them, enter the lights off and on time. All times should be entered in the format: hh:mm:ss.sss. If lights off/on times are not specified, danalyzer will assume that lights off was at the start of recording, and lights on was at the end of the recording . Keep the epoch length field at the default 30 seconds. When everything is entered correctly, click Confirm to pull the data into the GUI. If everything went well, your data will appear something like this:","title":"Load data"},{"location":"gui-tutorial/#apply-a-montage","text":"You will likely want to change some details about how the data look for the purposes of sleep scoring (for example, adding a scale line). All of these alterations are controlled though a montage file, a MATLAB script that controls how the data are presented. To select a montage, click on the montage list and select which montage you want to use. When a particular montage is selected, the display will update accordingly: In this example, applying the montage added scale lines around channel F3. It also re-colored EOG and EMG channels blue and red respectively.","title":"Apply a montage"},{"location":"gui-tutorial/#editing-a-montage","text":"You can edit the motnage on-the-fly by navigating to Montage --> Edit montage (or by pressing the m key), which brings up a dialog window. You can specify any of the following changes: Scale : Integer specifying a new scale for all channels Scale channel : The channel that you wish the scale lines to be displayed around. Leaving this blank will remove the scale lines entirely Scale values : A value indicating where to place each scale line Scale color : A MATLAB RGB triplety indicating the color of the scale lines Hide channels : A list of channels you want to hide (i.e. remove from the display) Channel order : The order in which the channels are displayed. If you specify channels to hide, ensure that they are not listed in the channel order EEG color : The color of all EEG channels EOG color : The color of all EOG channels EMG color : The color of all EMG channels ECG color : The color of all ECG channels Other color : The color of all other channels Click OK to adopt these new settings. You can always revert back to a predefined montage by selecting it from the montage list. You can also clear the montage entirely by navigating to Montage --> Clear montage. Tip Rather than making on-the-fly changes each time, the best approach is to create a new montage file and add it to the list of available montages. See the Montage creation guide for full details. When you are happy with your montage settings, we can begin browsing the data and start sleep scoring!","title":"Editing a montage"},{"location":"gui-tutorial/#data-browsing-and-sleep-scoring","text":"Before you can interact with the GUI, you must click in an empty gray area of the GUI . Navigate between epochs by pressing the left or right arrow key. You can jump forwards or backwards in chunks of 10 epochs by clicking the >> or << buttons. The current epoch number is displayed in the bottom left. You can type any epoch number into this box to immediately jump to it. You can also move to a specific epoch by clicking on the corresponding space in the hypnogram window at the top of the GUI. The current scale of the data is indicated in the box next to the montage list (default is 150). The scale can be adjusted by typing a new scale value into the box, or using the +/- buttons to increase or decrease the scale in chunks of 25. Tip Scale units in danalyzer are essentially aribtary. danalyzer assumes the data are stored in microvolts, but this may not always be the case. If your data are all flat lines, one reason could be that the data are not microvolts. Sleep scoring is incredibly straightforward. Score an epoch simply by pressing the corresponding button on the keyboard: 0 = Wake 1 = N1 2 = N2 3 = N3 4 = N4 5 = REM 6 = Movement After scoring an epoch, the display will automatically advance. If you wish to unstage an epoch, press the period (.) key. As you score, you will see that the hypnogram also starts to be created. If you want to make any notes about the record that you are scoring, press the n key to bring up the Notes window. Here you can record any details about the record, and these notes will be saved alongside the score file.","title":"Data browsing and sleep scoring"},{"location":"gui-tutorial/#saving-sleep-scores","text":"When you have finished scoring a record, you will want to save the sleep scores. To save data, navigate to File --> Savd data or press CTRL/CMD + S to bring up the Save dialogue. As with loading data, danalyzer can also save many different kinds of data. To save sleep scores, type the directory or click the push button next to \"Save sleep scores\" (second row). If you use the push button, this will let you select a destination and name for the sleep scores. Navigate to the folder you wish to save to, and give the file a name. Then click save NOTE: YOUR DATA HAVE NOT SAVED YET . Then, in danalyzer, click the freen Save button to actually save your data. To verify that the scores have been saved, check that a .mat file has indeed appeared in the folder that you specified. There is nothing worse than not correctly saving your data after spending all that time sleep scoring! Tip Full documentation about the format of danalyzer files can be found here. If you need to import/export to other types of file, see here. You should now be at a point where you know how to load a dataset, apply a montage, and be comfortable with using danalyzer to sleep score. To learn more about the full functionality, see the relevant pages in the Reference tab on the sidebar. Happy sleep scoring!","title":"Saving sleep scores"},{"location":"matlab-control-statements/","text":"Control statements Control statements are an important part of MATLAB programming that you will use frequently when you are analyzing data. They essentially give you more flexible control over when and how code evaluates. There are only a few control statements, but it very important to have a good handle on how they work. All control statements follow the same basic anatomy: <controltype><conditional> <content> <alternatives> end If-then statements Sometimes just called if statements, these are probably the easiest to understand of all the control statements. if this is the case, then do this: if 2 > 1 disp('Big numbers are the best') end In an if statement, the conditional must return a single logical variable (i.e. true or false). If it does not, MATLAB will throw an error or attempt to inperpret the output of the statement as a logical. If the logical returns true, the then part of the statement (all the code between if and end) will be executed. if the logical returns false, no code will be run. It is common practice to indent code that falls between if and end. If you highlight your code and press CTRL + I, MATLAB will automatically format this for you. The above example only had one route to follow (is 2 greater than 1). You can add more alternative options using elseif and else : n = randn; % Randomly generate a single number if n > 0 disp('n is greater than 0') elseif n > 2 disp('n is greater than 2') elseif n < 0 && n > -5 disp('n is quite small') else dip('n is very small') end The first statement tests whether n is greater than 0. If it is, it will print the statement 'n is greater than 0'. So what if n isn't greater than zero. Then, MATLAB will evaluate each elseif statement in order . This is very important, and also means that the code that is evaluated after the first elseif statement will never be evaluated. As soon as any of the if, elseif statements is evaulated true, the rest of the statements are always ignored. Because if n > 2, it will always be true at n > 0. Let's take a look at the second elseif statement. This illurates that the conditional statement can have multiple elements. If you remember back to logical indexing, we used the & and | symbols for and and or operations. We can use the same here, except whenever we are evaulating a conditional statement, we need to use && or || . We can string as many and or or statements as we want. As long as it evaluates to a single logical variable, MATLAB will be happy. Finally we get the the else statement. An else statement just be for the end will capture anything that does not agree with any of the other statements. As such, you don't give an else statement any conditional to evaluate. As well as logical operations, there are many functions you can use that return a logical variable that can be used as conditionals in an if-then statement: n = []; if isempty(n) disp('n is empty') elseif ~isempty(n) if n > (str2num(n)) disp('n is greater than 0') else disp('n is not greater than 0') end end The funciton is empty returns true if the input variable is empty. Remember, if statements only evaluate if the conditional is true. So what if we wanted to do something if the variable is not empry. MATLAB recognises the ~ symbol to mean not, so placing it in front of the function means, in this case that ~isempty translates as is-not-empty. This piece of code also illusrates how you can next multiple if-then statements within each other. Question How else could you write the second conditional, instead of elseif ~isempty(n)? For-loop statements Along with if statements, for-loops are the control statement you are going to be using the most. A for-loop is used to evaluate a piece of code over multiple iterations: for i = 1:10 disp(num2str(i)) end Here, the variable i is called the \"looping variable\", and it goes from 1 - 10 in integer steps. for loops iterate as many times as there are elements in the looping variable. The looping variable can be whatever you wish, it does not have to start at 1, and it does not need to be in integers. However, this is setup is useful as it is very common to use the looping variable within a for loop to index into matrices (and other variable types). For example: a = 2:2:10; for i = 1:length(a) b(i) = a(i); end This for loop will loop a number of times = to the length of a. This is a very common setup for for loops. On each iteration of i, we will use the i to index into the ith position of a, and then assign that value to the ith position of b. Question What would happen if you wrote b = a(i); instead of b(i) = a(i)? When you have this code in the editor you will notice matlab is giving us a warning message. If we hover over the squiggly orange line MATLAB tells us \"The variable 'b' appears to change size on every loop iteration (within a script). Consider preallocating for speed\". In our for loop, we are incrementally increasing the size of the variable b on each iteration. This can cause issues with memory use and processing speed, because MATLAB will need to spend longer sorting out information in memory. Preallocating can improve evaluation time by \"reserving\" the maximum amount of space for the variable ahead of time. To preallocate (or initialize) a variable, you just create the variable before the loop, setting it to be the size that the variable will be at the end of the loop. Not only does this make MATLAB more efficient, it forces you think more carefully about the expected output of your code ahead of time. For numeric variables, common ways to initialize a variable is to fill the variable with all zeros, or all NaN (not a number): a = 2:2:10; b = zeros(1, 5); % Initialize with all zeros b = nan(1, 5); % Initialize with all NaN for i = 1:length(a) b(i) = a(i); end When writing data analysis scripts, if statements and for loops are going to be used frequently. Here are some general pieces of advice: Avoid using loops and if statements whenever possible. They are a great source of frustration and error, especially when there are multiple nested statements spanning hundreds of line. For loops are also slow. There are many cases where a for loop could be substituted for vectorized operations. Give looping variables an intuitive name. The letter i is often associated with looping variables. If you are looping across participants, calling the looping variable subi or sub_i makes it clear what is happening. Add a comment to each end statement to make it clear which statement it is ending. Although if statements and for loops will be the control statements you use the most, some knowledge of the other three control statements available in MATLAB is valuable, and will be useful in certain situations. While statements While loops are similar to for loops, and usually either can be used to accomplish the same task. The main differences is that in a for-loop you specify how many iterations to run through. A while loop will keep going until you tell it to stop i = 0 while true i = i + 1; disp(['Give me ' num2str(i) 'X more MATLAB!']) end This while loop will go on forever, because we have not told it when to stop. Tip If you have just ran this code, how would you get this process to stop? Pressing CTRL + C while focused on the Command Window will break the current operation and return control tou you. Because of this behavior, whenever we write a while loop we are going to need to specify a conditon under which the loop will end. We can achieve this with a \"logical toggle\" and include an if statement inside our while loop: % Generate a random number r = 50 * rand * 50; % Set the logical toggle to true toggle = true while toggle % While toggle = true r = r / 1.1; % Condition in which to end loop if r < 1 toggle = false; end disp(['Current value is ' num2str(r)]) end In this code we are first generating a number number. We when set the initial state of the toggle to be true. Inside the while loop, the code will keep evaluating until r < 1, which then switches the toggle to false, and thus ends the while loop. In general for loops and while loops can be used to achieve the same thing. The main factor when considering which one to use is whether you know how many iterations you want. If you do (for example, you know how many participants are in your data), a for loop is preferred. If the number of iterations are not known, you will need to use a while loop. Avoid loops whenever possible As a brief aside, when you are coding you should always be looking for ways to avoid using for/while loops. For one, they are more confusing to read and increase the risk of errors entering the analysis. Second, loops will take longer than a vectorized alternative: p = zeros(1, 1000000); % Initialize a 1 x 1 million array % Loop approach tic for i = 1:length(p) p(i) = i ^ 3; end toc % Vectorized approach tic p3 = 1(1:1000000) . ^ 3; toc The tic and toc commands time how long it takes to evaulate the code between tic and toc. See how when we run the for-loop it takes around 100ms to evaluate. When we perform the same calculation without a for loop, it only takes around 10ms. As such the for loop took 10 times as long to evaluate as the vectorized statement! Although 10 vs 100ms doesn't seem like much, these timing differences really add up over a long analysis with processes that might take seconds or minutes to complete. Like many things, for loops play a very important part of MATLAB programming and you will definitely need to use them in your analysis. This example just illustrates that they can be misued, and you should be mindful of that when programming. Try-catch statements This control statement can be translated as: try this, and if that doesn't work, do this instead. In a try-catch statement, MATLAB tries to run the code between try and catch . If it works, all code between catch and end is ignored. If it doesn't work however, MATLAB will note the error and instead try to run the code between catch and end : % Create a variable with two elements e = [1 4]; try % This will cause an error if e(3) > 3 disp('e(3) is bigger than 3') end catch me if e(2) > 3 disp('e(2) is gibber than 3') end end Question By now you should be able to figure out why the try catch part of the statement will cause an error. If not, here is a hint: Inspect the size of e, and then recall what we learned about indexing. In this code, the if statement between try and catch will cause an error, and so instead the catch end statement is evaulated instead. MATLAB will be helpful here, and put information about the error in variable me (this variable can be called anything you like, but me is common shorthand for Matlab Exception). As such, debugging difficult errors is the primary use of try-catch statements. A word of warning though. Do not use try catch statements as a way to write error-free code. Although errors are a huge source of frustration, they are helpful i ntelling you something is wrong! Placing error-ridden code inside a try-catch will not produce any errors, but your analysis will still be wrong. Switch-case statements This is the final in-built control statement, and I have yet to find a unique use for it. A switch-case statement provides something very similar to an if statement. switch holds the conditional statement 'in mind' and then tests whether that statement matches the various case s. otherwise works the same as an else statement: sleepStage = 'n2'; switch sleepstage case 'n2' disp('N2 sleep') case 'n3' disp('N3 sleep') otherwise disp('REM sleep') end Question How would you perform this switch-case statement as an if-else statement? Hint, use the help function to look up strcmp","title":"Control statements"},{"location":"matlab-control-statements/#control-statements","text":"Control statements are an important part of MATLAB programming that you will use frequently when you are analyzing data. They essentially give you more flexible control over when and how code evaluates. There are only a few control statements, but it very important to have a good handle on how they work. All control statements follow the same basic anatomy: <controltype><conditional> <content> <alternatives> end","title":"Control statements"},{"location":"matlab-control-statements/#if-then-statements","text":"Sometimes just called if statements, these are probably the easiest to understand of all the control statements. if this is the case, then do this: if 2 > 1 disp('Big numbers are the best') end In an if statement, the conditional must return a single logical variable (i.e. true or false). If it does not, MATLAB will throw an error or attempt to inperpret the output of the statement as a logical. If the logical returns true, the then part of the statement (all the code between if and end) will be executed. if the logical returns false, no code will be run. It is common practice to indent code that falls between if and end. If you highlight your code and press CTRL + I, MATLAB will automatically format this for you. The above example only had one route to follow (is 2 greater than 1). You can add more alternative options using elseif and else : n = randn; % Randomly generate a single number if n > 0 disp('n is greater than 0') elseif n > 2 disp('n is greater than 2') elseif n < 0 && n > -5 disp('n is quite small') else dip('n is very small') end The first statement tests whether n is greater than 0. If it is, it will print the statement 'n is greater than 0'. So what if n isn't greater than zero. Then, MATLAB will evaluate each elseif statement in order . This is very important, and also means that the code that is evaluated after the first elseif statement will never be evaluated. As soon as any of the if, elseif statements is evaulated true, the rest of the statements are always ignored. Because if n > 2, it will always be true at n > 0. Let's take a look at the second elseif statement. This illurates that the conditional statement can have multiple elements. If you remember back to logical indexing, we used the & and | symbols for and and or operations. We can use the same here, except whenever we are evaulating a conditional statement, we need to use && or || . We can string as many and or or statements as we want. As long as it evaluates to a single logical variable, MATLAB will be happy. Finally we get the the else statement. An else statement just be for the end will capture anything that does not agree with any of the other statements. As such, you don't give an else statement any conditional to evaluate. As well as logical operations, there are many functions you can use that return a logical variable that can be used as conditionals in an if-then statement: n = []; if isempty(n) disp('n is empty') elseif ~isempty(n) if n > (str2num(n)) disp('n is greater than 0') else disp('n is not greater than 0') end end The funciton is empty returns true if the input variable is empty. Remember, if statements only evaluate if the conditional is true. So what if we wanted to do something if the variable is not empry. MATLAB recognises the ~ symbol to mean not, so placing it in front of the function means, in this case that ~isempty translates as is-not-empty. This piece of code also illusrates how you can next multiple if-then statements within each other. Question How else could you write the second conditional, instead of elseif ~isempty(n)?","title":"If-then statements"},{"location":"matlab-control-statements/#for-loop-statements","text":"Along with if statements, for-loops are the control statement you are going to be using the most. A for-loop is used to evaluate a piece of code over multiple iterations: for i = 1:10 disp(num2str(i)) end Here, the variable i is called the \"looping variable\", and it goes from 1 - 10 in integer steps. for loops iterate as many times as there are elements in the looping variable. The looping variable can be whatever you wish, it does not have to start at 1, and it does not need to be in integers. However, this is setup is useful as it is very common to use the looping variable within a for loop to index into matrices (and other variable types). For example: a = 2:2:10; for i = 1:length(a) b(i) = a(i); end This for loop will loop a number of times = to the length of a. This is a very common setup for for loops. On each iteration of i, we will use the i to index into the ith position of a, and then assign that value to the ith position of b. Question What would happen if you wrote b = a(i); instead of b(i) = a(i)? When you have this code in the editor you will notice matlab is giving us a warning message. If we hover over the squiggly orange line MATLAB tells us \"The variable 'b' appears to change size on every loop iteration (within a script). Consider preallocating for speed\". In our for loop, we are incrementally increasing the size of the variable b on each iteration. This can cause issues with memory use and processing speed, because MATLAB will need to spend longer sorting out information in memory. Preallocating can improve evaluation time by \"reserving\" the maximum amount of space for the variable ahead of time. To preallocate (or initialize) a variable, you just create the variable before the loop, setting it to be the size that the variable will be at the end of the loop. Not only does this make MATLAB more efficient, it forces you think more carefully about the expected output of your code ahead of time. For numeric variables, common ways to initialize a variable is to fill the variable with all zeros, or all NaN (not a number): a = 2:2:10; b = zeros(1, 5); % Initialize with all zeros b = nan(1, 5); % Initialize with all NaN for i = 1:length(a) b(i) = a(i); end When writing data analysis scripts, if statements and for loops are going to be used frequently. Here are some general pieces of advice: Avoid using loops and if statements whenever possible. They are a great source of frustration and error, especially when there are multiple nested statements spanning hundreds of line. For loops are also slow. There are many cases where a for loop could be substituted for vectorized operations. Give looping variables an intuitive name. The letter i is often associated with looping variables. If you are looping across participants, calling the looping variable subi or sub_i makes it clear what is happening. Add a comment to each end statement to make it clear which statement it is ending. Although if statements and for loops will be the control statements you use the most, some knowledge of the other three control statements available in MATLAB is valuable, and will be useful in certain situations.","title":"For-loop statements"},{"location":"matlab-control-statements/#while-statements","text":"While loops are similar to for loops, and usually either can be used to accomplish the same task. The main differences is that in a for-loop you specify how many iterations to run through. A while loop will keep going until you tell it to stop i = 0 while true i = i + 1; disp(['Give me ' num2str(i) 'X more MATLAB!']) end This while loop will go on forever, because we have not told it when to stop. Tip If you have just ran this code, how would you get this process to stop? Pressing CTRL + C while focused on the Command Window will break the current operation and return control tou you. Because of this behavior, whenever we write a while loop we are going to need to specify a conditon under which the loop will end. We can achieve this with a \"logical toggle\" and include an if statement inside our while loop: % Generate a random number r = 50 * rand * 50; % Set the logical toggle to true toggle = true while toggle % While toggle = true r = r / 1.1; % Condition in which to end loop if r < 1 toggle = false; end disp(['Current value is ' num2str(r)]) end In this code we are first generating a number number. We when set the initial state of the toggle to be true. Inside the while loop, the code will keep evaluating until r < 1, which then switches the toggle to false, and thus ends the while loop. In general for loops and while loops can be used to achieve the same thing. The main factor when considering which one to use is whether you know how many iterations you want. If you do (for example, you know how many participants are in your data), a for loop is preferred. If the number of iterations are not known, you will need to use a while loop.","title":"While statements"},{"location":"matlab-control-statements/#avoid-loops-whenever-possible","text":"As a brief aside, when you are coding you should always be looking for ways to avoid using for/while loops. For one, they are more confusing to read and increase the risk of errors entering the analysis. Second, loops will take longer than a vectorized alternative: p = zeros(1, 1000000); % Initialize a 1 x 1 million array % Loop approach tic for i = 1:length(p) p(i) = i ^ 3; end toc % Vectorized approach tic p3 = 1(1:1000000) . ^ 3; toc The tic and toc commands time how long it takes to evaulate the code between tic and toc. See how when we run the for-loop it takes around 100ms to evaluate. When we perform the same calculation without a for loop, it only takes around 10ms. As such the for loop took 10 times as long to evaluate as the vectorized statement! Although 10 vs 100ms doesn't seem like much, these timing differences really add up over a long analysis with processes that might take seconds or minutes to complete. Like many things, for loops play a very important part of MATLAB programming and you will definitely need to use them in your analysis. This example just illustrates that they can be misued, and you should be mindful of that when programming.","title":"Avoid loops whenever possible"},{"location":"matlab-control-statements/#try-catch-statements","text":"This control statement can be translated as: try this, and if that doesn't work, do this instead. In a try-catch statement, MATLAB tries to run the code between try and catch . If it works, all code between catch and end is ignored. If it doesn't work however, MATLAB will note the error and instead try to run the code between catch and end : % Create a variable with two elements e = [1 4]; try % This will cause an error if e(3) > 3 disp('e(3) is bigger than 3') end catch me if e(2) > 3 disp('e(2) is gibber than 3') end end Question By now you should be able to figure out why the try catch part of the statement will cause an error. If not, here is a hint: Inspect the size of e, and then recall what we learned about indexing. In this code, the if statement between try and catch will cause an error, and so instead the catch end statement is evaulated instead. MATLAB will be helpful here, and put information about the error in variable me (this variable can be called anything you like, but me is common shorthand for Matlab Exception). As such, debugging difficult errors is the primary use of try-catch statements. A word of warning though. Do not use try catch statements as a way to write error-free code. Although errors are a huge source of frustration, they are helpful i ntelling you something is wrong! Placing error-ridden code inside a try-catch will not produce any errors, but your analysis will still be wrong.","title":"Try-catch statements"},{"location":"matlab-control-statements/#switch-case-statements","text":"This is the final in-built control statement, and I have yet to find a unique use for it. A switch-case statement provides something very similar to an if statement. switch holds the conditional statement 'in mind' and then tests whether that statement matches the various case s. otherwise works the same as an else statement: sleepStage = 'n2'; switch sleepstage case 'n2' disp('N2 sleep') case 'n3' disp('N3 sleep') otherwise disp('REM sleep') end Question How would you perform this switch-case statement as an if-else statement? Hint, use the help function to look up strcmp","title":"Switch-case statements"},{"location":"matlab-environment/","text":"The MATLAB environment The MATLAB GUI When you open MATLAB, you will see something similar the image below: This is the MATLAB graphical user interface, or GUI. All of the programming and running of code we will do will happen in this GUI. The GUI sometimes changes a little between versions. MATLAB releases two versions each year (an a and a b version). Differences tend to be minor, and you can usually run older code on a newer version of MATLAB. The reverse is often true as well, although newer functions won\u2019t be available in older versions. Everything we will be working with was written in 2016b and should work in all newer versions. You will see a series of different windows available to you: Command window : This is where you can interact with MATLAB. All code gets evaluated in the command window Edtior: This is where you view and edit MATLAB scripts or functions. All of your code will be evaulated here. If you don't have an editor window, you can open one by typing edit into the command window. Current folder: This shows your current working directory, all files in that directory, and the subdirectories. Workspace: This windows shows all the variables stored in the memory buffer for the current session, and will provide some information about each variable. The layout can be heavily customized. In the Home tab, you can go to Layout to edit the layout and reset to the default. By accessing Preferences you can customize almost everything about your MATLAB experience such a color scheme, keyboard shortcuts etc. Evaluating code All code is evaluated in the Command Window. You can type directly into the command window or copy-paste, but most of the time you are going to use scripts. Scripts are text files that can be opened by MATLAB (with the extension.m). Just having code in the Editor will not make it run. To make it run we need to evaluate it in the command window. There are multiple ways to do this, but the most convienent are: Highlight the line(s) you want to run, right click, and select Evaluate selection Highlight and press F9 (if on a PC. All shortcuts can be changed in preferences) With the editor active, press CTRL + ENTER Save the script in the current directory, then type the name of the script into the command window MATLAB files types There are several MATLAB file types that you should be aware of: .m: These are MATLAB script files that contain code .mat: These are MATLAB-readable datafiles that can be interacted with using the save and load commands. Of course these are not the only files MATLAB can read. We will talk more about importing/exporting different file types later one .fig: These are MATLAB-readable figures. .mex: You will probably not interact much with MEX files. These are compiled code used to make things run faster. Keyboard shortcuts There are lots of keyboard shortcuts that can be altered in the Preferences tab. Below are just a few of the more useful ones: CTRL + ENTER: Run all code in the editor/run the highlighted cell Tab: When you start typing in a function name, pressing tab will help complete it or give you a list of possible functions CTRL + R: Comment out an entire line CTRL + T: Uncomment a line CTRL + I: Smart indent. This is useful for helping to keep your code tidy. This will be particularly useful when we look at control statements CTRL + C: If pressed when the command window is active, it will break the current code and return control to you. This is invaluable when you want to stop a very long process (e.g. if you realize you made an error!). F9: Run the highlighted line of code F5: Run the entire script Up arrow: In the command window, press the up arrow to search through and re-evaluate previous lines of code Getting help Even the most seasoned MATLABer will spend considerable time accessing the help documentation. There are multiple ways to get help when using MATLAB. When calling a function, MATLAB will automatically provide hints about the input arguments it expects: In this example, the function mean has been called, and MATLAB tries to help by reminding you about which arguments you need. Often you are going to need more information to understand what a function does and what the various inputs and outputs are. The help function will print any other function's help to the command window: help mean This command will print the help file associated with the function mean. The MATLAB website also contains fairly useful documentation. When you run into situations you cannot solve, searching for your problem will often find you an answer. The MATLAB Answers help forum is a good place to look for solutions to problems. Code analyzer This is a built-in program that analyzes the code in the Editor window and looks for problems. A warning is given when the code analyzer detects code that will work but could be problematic in some circumstances. The part of the code giving the warning is highlighted by an orange squiggly line, and holding the cursor over the warning will give information about why MATLAB has thrown a warning: You do not necessarily need to fix all of the warnings, as the code will still run. However it is good practice to inspect each warning, consider why it is warning you, and if it needes to remedied. An error is given when it finds a line that MATLAB will crash on. Before running a script, you will need to fix any errors that the code analyzer finds. A script will never run while there are errors present. An error is highlighted with a red squiggly line. Like with warnings, holding the cursor over the error will give you some information: Although useful, do not rely solely on the code analyzer. It will not pick up all errors. It will also not save you from the worst errors of all, which are times when the code does not crash, but gives you the wrong outcome! Comments and cells When you are writing scripts, commenting is the second most important thing after the code itself. It serves as a reminder to you what each part of your script does, and will help others decipher what you are doing. Use the % symbol to write text as code: % This is a comment this is not a comment Within a script, typing %% will turn the script into a block or cell. You can evaluate individual cells by clicking into them and pressing CTRL + ENTER. Cells can also be a nice way to break up a long script into more manageable chunks. As we construct our own pipeline throughout the tools tutorial, we will sue cells to break the pipeline up into its main parts. Directories and paths MATLAB is always \u2018in\u2019 a directory. The current folder displays the directory MATLAB is currently in. You can also get the current directory using the pwd function. You can change the current directory using the cd function. Type in folder one level up. You can also go back one level in the current directory by typing cd .. The concept of the MATLAB path is a very important one, as it relates to where MATLAB looks for code. To understand how this works, consider the example below. We have written a small script (what it does does not matter much right now), and saved it in the working directory, and called it showmean: If we type showmean into the Command Window, we get an output: Now we are going to create a new folder in the working directory called tmp, and move the showmean script into that new folder. That MATLAB code for that is: % Make a new folder mkdir('tmp') movefile('movefile.m', 'tmp/movefile.m') After moving the file, we try to run showmean again. This time we get an error: Why doeds this happen? It is because MATLAB cannot see all the files on your computer. It only knows about files that are on the MATLAB path. The current directory is always on the path. We can add and remove other locations as needed. In the GUI, you can adjust the MATLAB path by clicking on the Home tav, then clicking Set Path. We can also do this with the addpath and rmpath functions: % Add a folder to the path addpath('path to add') % Remove a folder to the path rmpath('path to remove') Let's use addpath to add the tmp folder to the path, and try running showmean again: Success! showmean ran because MATLAB now knows to look in the tmp folder. Whenever you start an analysis, it is important you know which directories are on the MATLAB path. It is common to use addpath at the top of a script to add the relevant directories needed for an analysis. Having too many directories permanently on the path can cause MATLAB to run slow. I keep frequently used toolboxes on the path permanently using a startup file.","title":"The MATLAB environment"},{"location":"matlab-environment/#the-matlab-environment","text":"","title":"The MATLAB environment"},{"location":"matlab-environment/#the-matlab-gui","text":"When you open MATLAB, you will see something similar the image below: This is the MATLAB graphical user interface, or GUI. All of the programming and running of code we will do will happen in this GUI. The GUI sometimes changes a little between versions. MATLAB releases two versions each year (an a and a b version). Differences tend to be minor, and you can usually run older code on a newer version of MATLAB. The reverse is often true as well, although newer functions won\u2019t be available in older versions. Everything we will be working with was written in 2016b and should work in all newer versions. You will see a series of different windows available to you: Command window : This is where you can interact with MATLAB. All code gets evaluated in the command window Edtior: This is where you view and edit MATLAB scripts or functions. All of your code will be evaulated here. If you don't have an editor window, you can open one by typing edit into the command window. Current folder: This shows your current working directory, all files in that directory, and the subdirectories. Workspace: This windows shows all the variables stored in the memory buffer for the current session, and will provide some information about each variable. The layout can be heavily customized. In the Home tab, you can go to Layout to edit the layout and reset to the default. By accessing Preferences you can customize almost everything about your MATLAB experience such a color scheme, keyboard shortcuts etc.","title":"The MATLAB GUI"},{"location":"matlab-environment/#evaluating-code","text":"All code is evaluated in the Command Window. You can type directly into the command window or copy-paste, but most of the time you are going to use scripts. Scripts are text files that can be opened by MATLAB (with the extension.m). Just having code in the Editor will not make it run. To make it run we need to evaluate it in the command window. There are multiple ways to do this, but the most convienent are: Highlight the line(s) you want to run, right click, and select Evaluate selection Highlight and press F9 (if on a PC. All shortcuts can be changed in preferences) With the editor active, press CTRL + ENTER Save the script in the current directory, then type the name of the script into the command window","title":"Evaluating code"},{"location":"matlab-environment/#matlab-files-types","text":"There are several MATLAB file types that you should be aware of: .m: These are MATLAB script files that contain code .mat: These are MATLAB-readable datafiles that can be interacted with using the save and load commands. Of course these are not the only files MATLAB can read. We will talk more about importing/exporting different file types later one .fig: These are MATLAB-readable figures. .mex: You will probably not interact much with MEX files. These are compiled code used to make things run faster.","title":"MATLAB files types"},{"location":"matlab-environment/#keyboard-shortcuts","text":"There are lots of keyboard shortcuts that can be altered in the Preferences tab. Below are just a few of the more useful ones: CTRL + ENTER: Run all code in the editor/run the highlighted cell Tab: When you start typing in a function name, pressing tab will help complete it or give you a list of possible functions CTRL + R: Comment out an entire line CTRL + T: Uncomment a line CTRL + I: Smart indent. This is useful for helping to keep your code tidy. This will be particularly useful when we look at control statements CTRL + C: If pressed when the command window is active, it will break the current code and return control to you. This is invaluable when you want to stop a very long process (e.g. if you realize you made an error!). F9: Run the highlighted line of code F5: Run the entire script Up arrow: In the command window, press the up arrow to search through and re-evaluate previous lines of code","title":"Keyboard shortcuts"},{"location":"matlab-environment/#getting-help","text":"Even the most seasoned MATLABer will spend considerable time accessing the help documentation. There are multiple ways to get help when using MATLAB. When calling a function, MATLAB will automatically provide hints about the input arguments it expects: In this example, the function mean has been called, and MATLAB tries to help by reminding you about which arguments you need. Often you are going to need more information to understand what a function does and what the various inputs and outputs are. The help function will print any other function's help to the command window: help mean This command will print the help file associated with the function mean. The MATLAB website also contains fairly useful documentation. When you run into situations you cannot solve, searching for your problem will often find you an answer. The MATLAB Answers help forum is a good place to look for solutions to problems.","title":"Getting help"},{"location":"matlab-environment/#code-analyzer","text":"This is a built-in program that analyzes the code in the Editor window and looks for problems. A warning is given when the code analyzer detects code that will work but could be problematic in some circumstances. The part of the code giving the warning is highlighted by an orange squiggly line, and holding the cursor over the warning will give information about why MATLAB has thrown a warning: You do not necessarily need to fix all of the warnings, as the code will still run. However it is good practice to inspect each warning, consider why it is warning you, and if it needes to remedied. An error is given when it finds a line that MATLAB will crash on. Before running a script, you will need to fix any errors that the code analyzer finds. A script will never run while there are errors present. An error is highlighted with a red squiggly line. Like with warnings, holding the cursor over the error will give you some information: Although useful, do not rely solely on the code analyzer. It will not pick up all errors. It will also not save you from the worst errors of all, which are times when the code does not crash, but gives you the wrong outcome!","title":"Code analyzer"},{"location":"matlab-environment/#comments-and-cells","text":"When you are writing scripts, commenting is the second most important thing after the code itself. It serves as a reminder to you what each part of your script does, and will help others decipher what you are doing. Use the % symbol to write text as code: % This is a comment this is not a comment Within a script, typing %% will turn the script into a block or cell. You can evaluate individual cells by clicking into them and pressing CTRL + ENTER. Cells can also be a nice way to break up a long script into more manageable chunks. As we construct our own pipeline throughout the tools tutorial, we will sue cells to break the pipeline up into its main parts.","title":"Comments and cells"},{"location":"matlab-environment/#directories-and-paths","text":"MATLAB is always \u2018in\u2019 a directory. The current folder displays the directory MATLAB is currently in. You can also get the current directory using the pwd function. You can change the current directory using the cd function. Type in folder one level up. You can also go back one level in the current directory by typing cd .. The concept of the MATLAB path is a very important one, as it relates to where MATLAB looks for code. To understand how this works, consider the example below. We have written a small script (what it does does not matter much right now), and saved it in the working directory, and called it showmean: If we type showmean into the Command Window, we get an output: Now we are going to create a new folder in the working directory called tmp, and move the showmean script into that new folder. That MATLAB code for that is: % Make a new folder mkdir('tmp') movefile('movefile.m', 'tmp/movefile.m') After moving the file, we try to run showmean again. This time we get an error: Why doeds this happen? It is because MATLAB cannot see all the files on your computer. It only knows about files that are on the MATLAB path. The current directory is always on the path. We can add and remove other locations as needed. In the GUI, you can adjust the MATLAB path by clicking on the Home tav, then clicking Set Path. We can also do this with the addpath and rmpath functions: % Add a folder to the path addpath('path to add') % Remove a folder to the path rmpath('path to remove') Let's use addpath to add the tmp folder to the path, and try running showmean again: Success! showmean ran because MATLAB now knows to look in the tmp folder. Whenever you start an analysis, it is important you know which directories are on the MATLAB path. It is common to use addpath at the top of a script to add the relevant directories needed for an analysis. Having too many directories permanently on the path can cause MATLAB to run slow. I keep frequently used toolboxes on the path permanently using a startup file.","title":"Directories and paths"},{"location":"matlab-functions/","text":"Functions We have already talked about using the Editor to write scripts. A function is essentially the same thing as a script, except it gets modified less often and works inside its own workspace. All functions have a name and most need to be supplied an input. In exchange, the function returns one or more outputs to you. We have already seen several functions. For example, the function mean takes a set of numbers as an input, and gives you the average of those numbers as the output. In general, functions all follow the following syntax: output = functionname(input); Using functions Let's try working with a few different functions. To do this, we will need to create some data to work with. The function randn will generate a matrix of random numbers drawn from a normal distribution for us: data = randn(25, 1); Let us consider this line of code. The function name is randn . Then, inside the parentheses we provide our input arguments. We are providing the function with two input arguments, with each input separated by a comma. In this case, the function will return a matrix with 25 rows and one column. By using the = sign, we are assigning that output to the variable named data. Tip Don't forget that if you need more information about what a function does or what input it needs, always try: help functionname Ok now that we have our data, let's try using some more functions to get some information about the variable data. Remember, for each function we need to provide an input and assign a veraible to the output. In all these cases, we are going to use the variable data as our input: % Get the size of each dimension of the input. Very useful when debugging sizeData = size(data); % Find the minimum value of data minData = min(data); % Find the maximum value of data maxData = max(data); % Find the median of data medData = max(data); % Find the standard deviation of data stdData = std(data); Multiple inputs and outputs In the above examples, we gave each function one input, and returned a single output. This is not always the case however, and most functions can take more than one input argument, and can return more than one output. We already had an example of providing a function with two inputs when we generated our data, but let's look at another one. When we used the function size , the output gave us the size of each dimension. If we only wanted to know the size of say, the second dimension, we can do that by providing the dimension number as a second input to size: colSizeData = size(data, 2); As well as multiple inputs, many functions can return multiple outputs as well. Multiple outputs are separated by commas and contained in square brackets. max is just one example of function with more than output: [val, idx] = max(data); Here we have gotten two outputs from max. val is the same that we got when we ran max previously i.e. it is the value of the highest number in data . But what if you didn't want to know just what the maximum value is, but its position in the matrix? This is what the second output of max tells you. You can confirm that by entering data into the command window and manually checking the position of the largest value. Question Try using your indexing skills to retrive the value of the higher number in data, using the idx output of the previous command. Inputs as outputs The ouput of one function can be used as the input of another. This can save us space when writing code. For example, if we wanted to create a new variable of random numbers that is the same size as data we could write: sizeData = size(data); data2 = randn(sizeData); Alternatively, we could write: data2 = randn( size(data) ); Here the output of size is being directly fed into the input of randn. This means there is no need to create a new variable called sizeData and take up an extra line of code. While this approach is useful for writing consise code, some consideration are needed. First, you can only use the first output of a function as an input for another. If you wanted to use the second or third output of a function you would need to create an intermediate variable first. Second, it is possible to embed functions in this manner as many time as you want and need. For example: a = max(randn(size(data))); Here we are now not only using the output of size as the input of randn , we are then taking the output of randn and feeding it to the input the of max . When reading code like this, remember that the operations are heppening from the inside out. The inner most function is being evalulated first, followed by the function immediately to its left, and so on. As you add more and more functions this way, keep readability in mind! If you are more than three variables deep, you might want to consider breaking the code up into multiple steps. Writing functions Functions are just text files with a .m extension, the same as a script. In the command window type: edit mean to open the function mean in the editor. You will notice right at the top of the file the main difference between how a script and a function is formatted. the word function right at the start is telling MATLAB this is a function. After that the output(s), function name, and input(s) are specified. All of the commented text underneath the function definition are what gets printed out when you type help mean . After that comes the function code itself. You can write your own functions! Before you do, you should think about whether it is a good idea or not. Writing too many functions can cause problems with debugging, as it becomes harder and harder to figure out and remember what functions do, what variables are hard coded within functions etc. It also makes sharing code more difficult, because you will need to share all the functions you wrote in addition to your main script. A good reason to create your own function is if you have pieces of code that you find yourself needing over and over again. Rather than copy-pasting that code each time, you could write a function that you save on your MATLAB path. As an example, when I am analyzing data I frequently need to create a list of folders that contain each participant's data. Here is the code to do that: startFolder = 'root folder'; subList = dir(startFolder); isItAFolder = [subList(:).isdir]; subList = {subList(isItAfolder).name}'; subList(ismember(subList,{'.', '..'})) = []; This is five lines of code that I was using in almost all of my analysis scripts. As such I decided to write my own function called generatesublist : function subList = generatesublist(startFolder) % Generate a list of subject folders contained within startFolder subList = dir(startFolder); isItAFolder = [subList(:).isdir]; subList = {subList(isItAfolder).name}'; subList(ismember(subList,{'.', '..'})) = []; This means now when I want to create a list of folders, I just need to write: % Create a list of participant folders subList = generatesublist('root folder'); Much better! And by giving the function a helpful name and comment, it should be very clear to others what that custom function does. Create a function to calculate standard error So let's try writing our own function. A common statistic we use in data analysis is the standard error. Unfortunately however MATLAB does not provide an in-built function to calculate standard error. So let's do it ourselves. First, here is the equation for calculating standard error: We want to write a MATLAB function to perform that equation on a variable: output = standarderror(input); To start, we will open a new file in the editor. In the very first line we will specifiy this is a function, and then assign the function name, input, and output. You call these input and output variables whatever you like: function y = standarderror(x) Underneath that, we are going to want to explain what our function does, so that when users type help standarderror they can understand how to use the function: % Compute the standard error on input data % % Required input: % % x = A 1D numeric variable % % Output: % % y = The standard error % % Code written by:<your name here> Now save the file. The function file name should have the exact same name as the name of the function. Make sure you save it to the path. Now, try typing help standarderror into the command window. MATLAB should now print out the help file you just created. Ok, so now we need to write the code itself. The first thing we need to do is to calculate the standard deviation of our input: % Calculate the standard deviation xSTD = std(x); Now we need to find out how many 'samples' are in our input data. This will correspond to the number of elements of the variable. We can find the number of elements in the longest dimension by using the function length: % Length of the input xLength = length(x); Now we need to calculate the square root of the number of samples. Again, MATLAB has an in-built function for that: % Square root of the number of samples xSQRT = sqrt(xLength); So now we have calculated all of our component parts, we can perform the equation: % Calculate standard error y = xSTD / xSQRT; This is what the whole function looks like: function y = standarderror(x) % Compute the standard error on input data % % Required input: % % x = A 1D numeric variable % % Output: % % y = The standard error % % Code written by:<your name here> % Calculate the standard deviation xSTD = std(x); % Length of the input xLength = length(x); % Square root of the number of samples xSQRT = sqrt(xLength); % Calculate standard error y = xSTD / xSQRT; Question It took use four lines of code to calculate the standard error. Use your knowledge of inputs as outputs to shorten the function to just one line. Save your function again, we are now going to try running it on the random data we generated earier: seData = standarderror(data); Tip Take a look at your workspace. You will notice that none of the variables that we created in the function are in the workspace. This is because functions work within their own workspaces that cannot be accessed from the 'base' workspace. Debugging One last thing we need to know about functions is how to debug them. Debugging is an essential (and tedious) part of programming. Thankfully MATLAB provides some helpful debugging tools. If a function is broken, we will need to 'take a peek' inside the workings of that function to see what is wrong. Let's deliberately break our newly made standard error function: xSQRT = sqt(xLength); Question Why does this break the code? Save the function and run it again. Of course, we know this will cause can error. Take a look at the error message, it tells us which line of the function the error occurred on. So let's use some debugging tools to fix this problem. Make sure our function is open in the editor. You will see that for each line of code, there is a little horizontal line to the left of the code alongside the line number. These are parts of the code where a breakpoint can be inserted. Click on the horizontal line at line 24, the line which is causing the error. Now run the function again. This time, the function pauses at the line you put the breakpoint in. Take a look at the workspace, now we are 'in' the function workspace. You can navigate between workspaces by using the Function Call Stack menu in the toolbar. Now we are in the function's workspace we can try to diagnose and fix the error with our function. Thankfully the error is easy to fix this time (and in reality you probably would even need to use the debugger). Nevertheless, the principle is the same when you come across an error in your functions. Make sure to remove the breakpoint by clicking it again before you try to use the function again! Tip An important part about writing your own functions is that they should be generalizable to different situations and datasets. Think about how you could generalize standarderror to work on 2D matrics, and how could you add a second input argument to instruct the function as to which dimension to work along?","title":"Functions"},{"location":"matlab-functions/#functions","text":"We have already talked about using the Editor to write scripts. A function is essentially the same thing as a script, except it gets modified less often and works inside its own workspace. All functions have a name and most need to be supplied an input. In exchange, the function returns one or more outputs to you. We have already seen several functions. For example, the function mean takes a set of numbers as an input, and gives you the average of those numbers as the output. In general, functions all follow the following syntax: output = functionname(input);","title":"Functions"},{"location":"matlab-functions/#using-functions","text":"Let's try working with a few different functions. To do this, we will need to create some data to work with. The function randn will generate a matrix of random numbers drawn from a normal distribution for us: data = randn(25, 1); Let us consider this line of code. The function name is randn . Then, inside the parentheses we provide our input arguments. We are providing the function with two input arguments, with each input separated by a comma. In this case, the function will return a matrix with 25 rows and one column. By using the = sign, we are assigning that output to the variable named data. Tip Don't forget that if you need more information about what a function does or what input it needs, always try: help functionname Ok now that we have our data, let's try using some more functions to get some information about the variable data. Remember, for each function we need to provide an input and assign a veraible to the output. In all these cases, we are going to use the variable data as our input: % Get the size of each dimension of the input. Very useful when debugging sizeData = size(data); % Find the minimum value of data minData = min(data); % Find the maximum value of data maxData = max(data); % Find the median of data medData = max(data); % Find the standard deviation of data stdData = std(data);","title":"Using functions"},{"location":"matlab-functions/#multiple-inputs-and-outputs","text":"In the above examples, we gave each function one input, and returned a single output. This is not always the case however, and most functions can take more than one input argument, and can return more than one output. We already had an example of providing a function with two inputs when we generated our data, but let's look at another one. When we used the function size , the output gave us the size of each dimension. If we only wanted to know the size of say, the second dimension, we can do that by providing the dimension number as a second input to size: colSizeData = size(data, 2); As well as multiple inputs, many functions can return multiple outputs as well. Multiple outputs are separated by commas and contained in square brackets. max is just one example of function with more than output: [val, idx] = max(data); Here we have gotten two outputs from max. val is the same that we got when we ran max previously i.e. it is the value of the highest number in data . But what if you didn't want to know just what the maximum value is, but its position in the matrix? This is what the second output of max tells you. You can confirm that by entering data into the command window and manually checking the position of the largest value. Question Try using your indexing skills to retrive the value of the higher number in data, using the idx output of the previous command.","title":"Multiple inputs and outputs"},{"location":"matlab-functions/#inputs-as-outputs","text":"The ouput of one function can be used as the input of another. This can save us space when writing code. For example, if we wanted to create a new variable of random numbers that is the same size as data we could write: sizeData = size(data); data2 = randn(sizeData); Alternatively, we could write: data2 = randn( size(data) ); Here the output of size is being directly fed into the input of randn. This means there is no need to create a new variable called sizeData and take up an extra line of code. While this approach is useful for writing consise code, some consideration are needed. First, you can only use the first output of a function as an input for another. If you wanted to use the second or third output of a function you would need to create an intermediate variable first. Second, it is possible to embed functions in this manner as many time as you want and need. For example: a = max(randn(size(data))); Here we are now not only using the output of size as the input of randn , we are then taking the output of randn and feeding it to the input the of max . When reading code like this, remember that the operations are heppening from the inside out. The inner most function is being evalulated first, followed by the function immediately to its left, and so on. As you add more and more functions this way, keep readability in mind! If you are more than three variables deep, you might want to consider breaking the code up into multiple steps.","title":"Inputs as outputs"},{"location":"matlab-functions/#writing-functions","text":"Functions are just text files with a .m extension, the same as a script. In the command window type: edit mean to open the function mean in the editor. You will notice right at the top of the file the main difference between how a script and a function is formatted. the word function right at the start is telling MATLAB this is a function. After that the output(s), function name, and input(s) are specified. All of the commented text underneath the function definition are what gets printed out when you type help mean . After that comes the function code itself. You can write your own functions! Before you do, you should think about whether it is a good idea or not. Writing too many functions can cause problems with debugging, as it becomes harder and harder to figure out and remember what functions do, what variables are hard coded within functions etc. It also makes sharing code more difficult, because you will need to share all the functions you wrote in addition to your main script. A good reason to create your own function is if you have pieces of code that you find yourself needing over and over again. Rather than copy-pasting that code each time, you could write a function that you save on your MATLAB path. As an example, when I am analyzing data I frequently need to create a list of folders that contain each participant's data. Here is the code to do that: startFolder = 'root folder'; subList = dir(startFolder); isItAFolder = [subList(:).isdir]; subList = {subList(isItAfolder).name}'; subList(ismember(subList,{'.', '..'})) = []; This is five lines of code that I was using in almost all of my analysis scripts. As such I decided to write my own function called generatesublist : function subList = generatesublist(startFolder) % Generate a list of subject folders contained within startFolder subList = dir(startFolder); isItAFolder = [subList(:).isdir]; subList = {subList(isItAfolder).name}'; subList(ismember(subList,{'.', '..'})) = []; This means now when I want to create a list of folders, I just need to write: % Create a list of participant folders subList = generatesublist('root folder'); Much better! And by giving the function a helpful name and comment, it should be very clear to others what that custom function does.","title":"Writing functions"},{"location":"matlab-functions/#create-a-function-to-calculate-standard-error","text":"So let's try writing our own function. A common statistic we use in data analysis is the standard error. Unfortunately however MATLAB does not provide an in-built function to calculate standard error. So let's do it ourselves. First, here is the equation for calculating standard error: We want to write a MATLAB function to perform that equation on a variable: output = standarderror(input); To start, we will open a new file in the editor. In the very first line we will specifiy this is a function, and then assign the function name, input, and output. You call these input and output variables whatever you like: function y = standarderror(x) Underneath that, we are going to want to explain what our function does, so that when users type help standarderror they can understand how to use the function: % Compute the standard error on input data % % Required input: % % x = A 1D numeric variable % % Output: % % y = The standard error % % Code written by:<your name here> Now save the file. The function file name should have the exact same name as the name of the function. Make sure you save it to the path. Now, try typing help standarderror into the command window. MATLAB should now print out the help file you just created. Ok, so now we need to write the code itself. The first thing we need to do is to calculate the standard deviation of our input: % Calculate the standard deviation xSTD = std(x); Now we need to find out how many 'samples' are in our input data. This will correspond to the number of elements of the variable. We can find the number of elements in the longest dimension by using the function length: % Length of the input xLength = length(x); Now we need to calculate the square root of the number of samples. Again, MATLAB has an in-built function for that: % Square root of the number of samples xSQRT = sqrt(xLength); So now we have calculated all of our component parts, we can perform the equation: % Calculate standard error y = xSTD / xSQRT; This is what the whole function looks like: function y = standarderror(x) % Compute the standard error on input data % % Required input: % % x = A 1D numeric variable % % Output: % % y = The standard error % % Code written by:<your name here> % Calculate the standard deviation xSTD = std(x); % Length of the input xLength = length(x); % Square root of the number of samples xSQRT = sqrt(xLength); % Calculate standard error y = xSTD / xSQRT; Question It took use four lines of code to calculate the standard error. Use your knowledge of inputs as outputs to shorten the function to just one line. Save your function again, we are now going to try running it on the random data we generated earier: seData = standarderror(data); Tip Take a look at your workspace. You will notice that none of the variables that we created in the function are in the workspace. This is because functions work within their own workspaces that cannot be accessed from the 'base' workspace.","title":"Create a function to calculate standard error"},{"location":"matlab-functions/#debugging","text":"One last thing we need to know about functions is how to debug them. Debugging is an essential (and tedious) part of programming. Thankfully MATLAB provides some helpful debugging tools. If a function is broken, we will need to 'take a peek' inside the workings of that function to see what is wrong. Let's deliberately break our newly made standard error function: xSQRT = sqt(xLength); Question Why does this break the code? Save the function and run it again. Of course, we know this will cause can error. Take a look at the error message, it tells us which line of the function the error occurred on. So let's use some debugging tools to fix this problem. Make sure our function is open in the editor. You will see that for each line of code, there is a little horizontal line to the left of the code alongside the line number. These are parts of the code where a breakpoint can be inserted. Click on the horizontal line at line 24, the line which is causing the error. Now run the function again. This time, the function pauses at the line you put the breakpoint in. Take a look at the workspace, now we are 'in' the function workspace. You can navigate between workspaces by using the Function Call Stack menu in the toolbar. Now we are in the function's workspace we can try to diagnose and fix the error with our function. Thankfully the error is easy to fix this time (and in reality you probably would even need to use the debugger). Nevertheless, the principle is the same when you come across an error in your functions. Make sure to remove the breakpoint by clicking it again before you try to use the function again! Tip An important part about writing your own functions is that they should be generalizable to different situations and datasets. Think about how you could generalize standarderror to work on 2D matrics, and how could you add a second input argument to instruct the function as to which dimension to work along?","title":"Debugging"},{"location":"matlab-import-export/","text":"Importing/exporting In theory, MATLAB can work with almost any kind of input data, so long as you are able to figure out how to import it. We will talk specifically about importing EEG data in a later tutorial, but for now we will cover some basic principles about importing/exporting that will be important for your own MATLAB skills Loading and saving .mat files A .mat file is the native MATLAB data format, and so is by far the easiest type of data to import: load matlabData.mat This line will load the contents of the .mat file into MATLAB. A single .mat file can hold multiple variables. Don't forget that if the .mat file is not on the path, you will need to provide the full directory. Question Use the whos command to figure out the number, size, and types of the variables that were just loaded You can assign the contents of a .mat file to a variable of your own choosing: d = load(matlabData.mat); In cases, such as this, where the .mat file holds multiple variables, those variables will become fields of a structure called d. Assigning data to variables this way will help to prevent data being overwritten if you load multiple .mat files containing the same variable names (for example if you are loading data from multiple participants). You can save variables in the MATLAB workspace to disk using the save command. if you simply type save into the Command Window, matlab will save the entire contents of the workspace to a variable called matlab.mat. Usually you want to be more selectively than that: save('output_filename.mat', 'var1', 'var2', 'var3') This code will save a .mat file called output_filename, and in that .mat file will be the variables var1 , var2 , var3 . Note that both the file name and all of the variables you wish to save must be inside single quotation marks. It is generally advisable to keep .mat files as small as possible, and within a single analysis/study to use a consistent file naming structure to keep things neat and tidy. When we start working with real data, you will find that sleep scores, artifact rejection information, and spectral analysis output will all be saved as .mat files. readtable/writetable Data in a tabular format (e.g. csv, Excel, and potentially text files) can be easily imported into matlab using the readtable function. This function will import the data into a table variable, with the column names corresponding to the column names in the imported file: t = readtable('exampleTable.csv', 'ReadVariableNames', true); Note the input argument 'ReadVariableNames'. This is an example of a key-value function input. It works by specififying the type of input you are requesting (i.e. the key, in this example ReadVariableNames), followed by the value for that input argument (i.e. the value). Here we are telling the function to use the first row of the table as variable names. If you have a table variable, you can easily write it to a .csv or Excel file by using writetable: writetable(t, 'newTable.csv', 'WriteVariableNames', true); The syntax for writetable is very similar to readtable. The first input is the table variable we want to save, and the second input is the name of the table. If you just specify the name, MATLAB will save the table to the current directory. If you want to save it someplace else, you will need to specify the full directory. The key-value input WriteVariableNames works how you imagine. This input is instructing MATLAB to include column names on the first row of the exported table. Loading text files The load and readtable commands work great with clean, easy to import data. For example, if a text file contains only numbers and each row has the same number of columns, the load command can handle it no problem: load('easy_text_file.txt')","title":"Importing/exporting"},{"location":"matlab-import-export/#importingexporting","text":"In theory, MATLAB can work with almost any kind of input data, so long as you are able to figure out how to import it. We will talk specifically about importing EEG data in a later tutorial, but for now we will cover some basic principles about importing/exporting that will be important for your own MATLAB skills","title":"Importing/exporting"},{"location":"matlab-import-export/#loading-and-saving-mat-files","text":"A .mat file is the native MATLAB data format, and so is by far the easiest type of data to import: load matlabData.mat This line will load the contents of the .mat file into MATLAB. A single .mat file can hold multiple variables. Don't forget that if the .mat file is not on the path, you will need to provide the full directory. Question Use the whos command to figure out the number, size, and types of the variables that were just loaded You can assign the contents of a .mat file to a variable of your own choosing: d = load(matlabData.mat); In cases, such as this, where the .mat file holds multiple variables, those variables will become fields of a structure called d. Assigning data to variables this way will help to prevent data being overwritten if you load multiple .mat files containing the same variable names (for example if you are loading data from multiple participants). You can save variables in the MATLAB workspace to disk using the save command. if you simply type save into the Command Window, matlab will save the entire contents of the workspace to a variable called matlab.mat. Usually you want to be more selectively than that: save('output_filename.mat', 'var1', 'var2', 'var3') This code will save a .mat file called output_filename, and in that .mat file will be the variables var1 , var2 , var3 . Note that both the file name and all of the variables you wish to save must be inside single quotation marks. It is generally advisable to keep .mat files as small as possible, and within a single analysis/study to use a consistent file naming structure to keep things neat and tidy. When we start working with real data, you will find that sleep scores, artifact rejection information, and spectral analysis output will all be saved as .mat files.","title":"Loading and saving .mat files"},{"location":"matlab-import-export/#readtablewritetable","text":"Data in a tabular format (e.g. csv, Excel, and potentially text files) can be easily imported into matlab using the readtable function. This function will import the data into a table variable, with the column names corresponding to the column names in the imported file: t = readtable('exampleTable.csv', 'ReadVariableNames', true); Note the input argument 'ReadVariableNames'. This is an example of a key-value function input. It works by specififying the type of input you are requesting (i.e. the key, in this example ReadVariableNames), followed by the value for that input argument (i.e. the value). Here we are telling the function to use the first row of the table as variable names. If you have a table variable, you can easily write it to a .csv or Excel file by using writetable: writetable(t, 'newTable.csv', 'WriteVariableNames', true); The syntax for writetable is very similar to readtable. The first input is the table variable we want to save, and the second input is the name of the table. If you just specify the name, MATLAB will save the table to the current directory. If you want to save it someplace else, you will need to specify the full directory. The key-value input WriteVariableNames works how you imagine. This input is instructing MATLAB to include column names on the first row of the exported table.","title":"readtable/writetable"},{"location":"matlab-import-export/#loading-text-files","text":"The load and readtable commands work great with clean, easy to import data. For example, if a text file contains only numbers and each row has the same number of columns, the load command can handle it no problem: load('easy_text_file.txt')","title":"Loading text files"},{"location":"matlab-indexing/","text":"Indexing When you have very large arrays, you are often only going to want to access a part of it. Indexing is the way to this, and is a critical skill to learn. This section will show you the basics of indexing the various kinds of variables we learned about previously. We will also introduce the concept of logical indexing and how it can be used to find parts of a variable that meet a certain criteria. The best way to get a complete feel of how indexing works is to practice, practice, practice! The colon operator To start, we will create a large array: % Create a large array bigArray = 1:2:200; Before we learn about indexing, we should talk briefly about the colon operator. The colon operator essentially acts as automatic number calculator: 1:10 If you run that in the command window, you will see the use of the colon has counted from 1 to 10 in steps of 1. You can count in steps other than 1: 1:2:10 By adding the middle number, this tells MATLAB what to count in i.e. count from 1 to 10 in steps of 2. Notice how when you do this, the output stops at 9 and not 11. You can concatenate numbers defined using the colon operator and single values by enclosing them in square brackets to form an array: [1:2:5 8 1:1:10] As we will see below, the colon operator comes in very handy when indexing multiple elements Indexing numeric variables Indexing lets us access specific parts of a variable. In the case of bigArray which we defined at the top, let's say we want to know the value of the number in the tenth position. We simply do this using parentheses () : % Index the tenth element of bigArray bigArray(10) In the command window, MATLAB prints out the value. If we wanted to store that output, we could assign the output of the indexing to a new variable: resultOfIndex = bigArray(10); By using square brackets inside the parentheses you can index multiple elements: bigArray([1 2 3 4 5 10 17 24]) We can save ourselves a bit of work here and use the colon operator to specify element 1:5, rather than typing each number out separately: bigArray([1:5 10 17 24]) When you are working with multidimensional arrays, use a comma to separate each dimension. For example, if you wanted to index the first row and tenth column of a 2D matrix: % Make a 2D matrix biggerArray = [1:2:100; 1:1:100]; biggerArray(1, 10) Tip If you index just one dimension of a matrix, MATLAB will always start from row 1. So: biggerArray(1) will index row 1, column 1. If you were to write: biggerArray(2) MATLAB will index row 2 column 1. When a single dimension is indexed in a 2D matrix, MATLAB will move through each row first, before advancing to the next column. This same principle applies when working with higher dimensions matrices as well. If you type just a colon by itself, the result would be to index every element in that dimension: % Index every element in the first row biggerArray(1, :) If you index a position that is outside of the dimensions of the variable, MATLAB gets upset and throws an error: % Index element 1 in row 3 biggerArray(3, 1) Index exceeds array bounds. This is a common error to see as you start writing more and more complex scripts. These errors often arrive when a variable you are creating is not the size you expect to be. Indexing character variables You can index a character array in the exact same way you index numeric variables: charArray = 'The quick brown fox jumped over the lazy dog'; % Index the 5th-9th characters charArray(5:9) % Use square brackets to access multiple elements charArray([1:3 5:9 42:44]) Question Try assigning \"the quick brown fox jumped over the lazy dog\" as a string array instead of a character array. Then try to index elements 5:9. What happens? What does this tell you about the difference between character and string arrays? Indexing cell arrays The same concept applies to indexing cell arrays, but there is an important difference between using parentheses () and curley brackets {} : % Make a 2D cell bigCell = {[2 3 4 1] [1 2 7 6 5] 'words'; [1 2 0] [6 5 7 1 3 6] 1}; % Index using parentheses bigCell(1) % Index using curly brackets bigCell{1} bigCell(1) ans = 1\u00d71 cell array {1\u00d74 double} bigCell{1} ans = 2 3 4 1 This clearly gives us quite different results. What is going on here? When you use the the parentheses, it is giving you the element present in position 1. In this case that is a cell containing a numeric array. That is why the output is a 1x1 cell array containing a 1x4 numeric array. If we want to access the contents of the cell in position 1, we need to use the curly brackets to get at what is inside the cell. Once we are inside the cell, we can then index the numeric variable inside: % Index first three elements of the array inside the cell bigCell{1}(1:3) Question Based on this, how would you index the second letter of the character array in bigCell? Indexing structures As with other variables, you can index elements of a structure using parentheses. Let's create a structure with three entries, similar to what we might have after detecting sleep spindles: % Create a structure spindles(1).label = 'Fz'; spindles(1).density = 4.1; spindles(1).amplitude = 28; spindles(2).label = 'Cz'; spindles(2).density = 4.8; spindles(2).amplitude = 24; spindles(3).label = 'Pz'; spindles(3).density = 5.2; spindles(3).amplitude = 17; We can access any of the entries in the structure using parentheses like we would for any other variable type: spindles(1) ans = struct with fields: label: 'Fz' density: 4.1000 amplitude: 28 This gives us the content of each field in the first entry. This can easily be extended to retrieve the content of a specific field: spindles(1).density ans = 4.1000 So what if you wanted to access multiple entries? If you write: spindles([1 3]).density you will notice that MATLAB returns each element as a separate answer, one for each entry in the strucutre. To concatenate the output of a structure, use square or curly brackets: [spindles([1 3]).density] Question Try the line above again, this time for the label field. Try using both square and curly brackets to concatenate the output. What are differences? When might one be more useful than the other? Indexing tables There are two different ways to index a table. First, lets start by creating one: bigTable = table([\"ppt1\"; \"ppt2\"; \"ppt3\"], [4.6; 6.1; 2.3], [30; 50; 17],... 'VariableNames', {'subid', 'spindles', 'memory'}); Tip What are the meaning of those three dots (ellipsis) at the end of the first line? This is how you can get MATLAB to continue long statements across multiple lines. This comes in very handy when performing particularly long operations. We can index a specific element or set of values by using parentheses or curly brackets. The difference is conceptually similar to that of cell arrays. Using parentheses will always return a table element, whereas curly brackets will give you what is \"inside\" that table table element: % Index using parentheses bigTable(1, 2) % Index using curly brackets bigTable{1, 2} bigTable(1, 2) ans = table spindles ________ 4.6 bigTable{1, 2} ans = 4.6000 Unlike other kinds of variable, when indexing a table you must specify a value for both dimensions of a table (i.e) a row and a column. A second way to index a table is by using the column names and a the period key: bigTable.spindles This looks similar to what we were doing with structure arrays. However, unlike a structure, when you index a table variable it concatenates all of the elements in the output for you. You can index a particular row(s) based on a column name using parentheses: bigTable.spindles(1) This will give you the first row of the column labeled spindles. Logical indexing What if we don't want to access elements in a particular location, but want to access elements that fit a certain set of criteria? By combining our new knoledge of indexing with logical variables that we learned about earlier, we can perform logical indexing. Logical indexing works by providing a statement which MATLAB can evaluate for each element in the variable we are indexing, and return only those elements who returned true to the statement. For example: a = 1:5; a([true true false true false]) ans = 1 2 4 This returns only elements 1, 2, and 4, because logical indexing accessed those elements. This is what happens when we use logical operators to find elements that fit a critera. For example, if we wanted to all the elements in that array that were greater than 3: a > 3 ans = 1\u00d75 logical array 0 0 0 1 1 This statement returns a logical array with the length of a. As expected, only elements 4 and 5 returned true because they were greater than three. So to get those elements directly we would write: a(a > 3) ans = 4 5 This is the logic behind logical indexing. Any operator or function that returns as a logical variable can be used in logical indexing. As you gain more experience with MATLAB, you will start to realize just how creative you can be with logical indexing! Question Try experimenting with the other logical operators. How does the operation >= differ from >? What if you wanted to only index elements that fitted two criteria. It is possible to combine different logical operations using two new commands, the & and | operators. The & operator is used when you want to index elements who return true to all the logical operators. The | works as an or operator. Use this when you want to index elements who return true to any of the logical operators. % Index elements who are greater than 2 AND less than 4 a(a > 2 & a < 4) % Index elements who are less than 2 OR greater than 4 a(a < 2 | a > 4)","title":"Indexing"},{"location":"matlab-indexing/#indexing","text":"When you have very large arrays, you are often only going to want to access a part of it. Indexing is the way to this, and is a critical skill to learn. This section will show you the basics of indexing the various kinds of variables we learned about previously. We will also introduce the concept of logical indexing and how it can be used to find parts of a variable that meet a certain criteria. The best way to get a complete feel of how indexing works is to practice, practice, practice!","title":"Indexing"},{"location":"matlab-indexing/#the-colon-operator","text":"To start, we will create a large array: % Create a large array bigArray = 1:2:200; Before we learn about indexing, we should talk briefly about the colon operator. The colon operator essentially acts as automatic number calculator: 1:10 If you run that in the command window, you will see the use of the colon has counted from 1 to 10 in steps of 1. You can count in steps other than 1: 1:2:10 By adding the middle number, this tells MATLAB what to count in i.e. count from 1 to 10 in steps of 2. Notice how when you do this, the output stops at 9 and not 11. You can concatenate numbers defined using the colon operator and single values by enclosing them in square brackets to form an array: [1:2:5 8 1:1:10] As we will see below, the colon operator comes in very handy when indexing multiple elements","title":"The colon operator"},{"location":"matlab-indexing/#indexing-numeric-variables","text":"Indexing lets us access specific parts of a variable. In the case of bigArray which we defined at the top, let's say we want to know the value of the number in the tenth position. We simply do this using parentheses () : % Index the tenth element of bigArray bigArray(10) In the command window, MATLAB prints out the value. If we wanted to store that output, we could assign the output of the indexing to a new variable: resultOfIndex = bigArray(10); By using square brackets inside the parentheses you can index multiple elements: bigArray([1 2 3 4 5 10 17 24]) We can save ourselves a bit of work here and use the colon operator to specify element 1:5, rather than typing each number out separately: bigArray([1:5 10 17 24]) When you are working with multidimensional arrays, use a comma to separate each dimension. For example, if you wanted to index the first row and tenth column of a 2D matrix: % Make a 2D matrix biggerArray = [1:2:100; 1:1:100]; biggerArray(1, 10) Tip If you index just one dimension of a matrix, MATLAB will always start from row 1. So: biggerArray(1) will index row 1, column 1. If you were to write: biggerArray(2) MATLAB will index row 2 column 1. When a single dimension is indexed in a 2D matrix, MATLAB will move through each row first, before advancing to the next column. This same principle applies when working with higher dimensions matrices as well. If you type just a colon by itself, the result would be to index every element in that dimension: % Index every element in the first row biggerArray(1, :) If you index a position that is outside of the dimensions of the variable, MATLAB gets upset and throws an error: % Index element 1 in row 3 biggerArray(3, 1) Index exceeds array bounds. This is a common error to see as you start writing more and more complex scripts. These errors often arrive when a variable you are creating is not the size you expect to be.","title":"Indexing numeric variables"},{"location":"matlab-indexing/#indexing-character-variables","text":"You can index a character array in the exact same way you index numeric variables: charArray = 'The quick brown fox jumped over the lazy dog'; % Index the 5th-9th characters charArray(5:9) % Use square brackets to access multiple elements charArray([1:3 5:9 42:44]) Question Try assigning \"the quick brown fox jumped over the lazy dog\" as a string array instead of a character array. Then try to index elements 5:9. What happens? What does this tell you about the difference between character and string arrays?","title":"Indexing character variables"},{"location":"matlab-indexing/#indexing-cell-arrays","text":"The same concept applies to indexing cell arrays, but there is an important difference between using parentheses () and curley brackets {} : % Make a 2D cell bigCell = {[2 3 4 1] [1 2 7 6 5] 'words'; [1 2 0] [6 5 7 1 3 6] 1}; % Index using parentheses bigCell(1) % Index using curly brackets bigCell{1} bigCell(1) ans = 1\u00d71 cell array {1\u00d74 double} bigCell{1} ans = 2 3 4 1 This clearly gives us quite different results. What is going on here? When you use the the parentheses, it is giving you the element present in position 1. In this case that is a cell containing a numeric array. That is why the output is a 1x1 cell array containing a 1x4 numeric array. If we want to access the contents of the cell in position 1, we need to use the curly brackets to get at what is inside the cell. Once we are inside the cell, we can then index the numeric variable inside: % Index first three elements of the array inside the cell bigCell{1}(1:3) Question Based on this, how would you index the second letter of the character array in bigCell?","title":"Indexing cell arrays"},{"location":"matlab-indexing/#indexing-structures","text":"As with other variables, you can index elements of a structure using parentheses. Let's create a structure with three entries, similar to what we might have after detecting sleep spindles: % Create a structure spindles(1).label = 'Fz'; spindles(1).density = 4.1; spindles(1).amplitude = 28; spindles(2).label = 'Cz'; spindles(2).density = 4.8; spindles(2).amplitude = 24; spindles(3).label = 'Pz'; spindles(3).density = 5.2; spindles(3).amplitude = 17; We can access any of the entries in the structure using parentheses like we would for any other variable type: spindles(1) ans = struct with fields: label: 'Fz' density: 4.1000 amplitude: 28 This gives us the content of each field in the first entry. This can easily be extended to retrieve the content of a specific field: spindles(1).density ans = 4.1000 So what if you wanted to access multiple entries? If you write: spindles([1 3]).density you will notice that MATLAB returns each element as a separate answer, one for each entry in the strucutre. To concatenate the output of a structure, use square or curly brackets: [spindles([1 3]).density] Question Try the line above again, this time for the label field. Try using both square and curly brackets to concatenate the output. What are differences? When might one be more useful than the other?","title":"Indexing structures"},{"location":"matlab-indexing/#indexing-tables","text":"There are two different ways to index a table. First, lets start by creating one: bigTable = table([\"ppt1\"; \"ppt2\"; \"ppt3\"], [4.6; 6.1; 2.3], [30; 50; 17],... 'VariableNames', {'subid', 'spindles', 'memory'}); Tip What are the meaning of those three dots (ellipsis) at the end of the first line? This is how you can get MATLAB to continue long statements across multiple lines. This comes in very handy when performing particularly long operations. We can index a specific element or set of values by using parentheses or curly brackets. The difference is conceptually similar to that of cell arrays. Using parentheses will always return a table element, whereas curly brackets will give you what is \"inside\" that table table element: % Index using parentheses bigTable(1, 2) % Index using curly brackets bigTable{1, 2} bigTable(1, 2) ans = table spindles ________ 4.6 bigTable{1, 2} ans = 4.6000 Unlike other kinds of variable, when indexing a table you must specify a value for both dimensions of a table (i.e) a row and a column. A second way to index a table is by using the column names and a the period key: bigTable.spindles This looks similar to what we were doing with structure arrays. However, unlike a structure, when you index a table variable it concatenates all of the elements in the output for you. You can index a particular row(s) based on a column name using parentheses: bigTable.spindles(1) This will give you the first row of the column labeled spindles.","title":"Indexing tables"},{"location":"matlab-indexing/#logical-indexing","text":"What if we don't want to access elements in a particular location, but want to access elements that fit a certain set of criteria? By combining our new knoledge of indexing with logical variables that we learned about earlier, we can perform logical indexing. Logical indexing works by providing a statement which MATLAB can evaluate for each element in the variable we are indexing, and return only those elements who returned true to the statement. For example: a = 1:5; a([true true false true false]) ans = 1 2 4 This returns only elements 1, 2, and 4, because logical indexing accessed those elements. This is what happens when we use logical operators to find elements that fit a critera. For example, if we wanted to all the elements in that array that were greater than 3: a > 3 ans = 1\u00d75 logical array 0 0 0 1 1 This statement returns a logical array with the length of a. As expected, only elements 4 and 5 returned true because they were greater than three. So to get those elements directly we would write: a(a > 3) ans = 4 5 This is the logic behind logical indexing. Any operator or function that returns as a logical variable can be used in logical indexing. As you gain more experience with MATLAB, you will start to realize just how creative you can be with logical indexing! Question Try experimenting with the other logical operators. How does the operation >= differ from >? What if you wanted to only index elements that fitted two criteria. It is possible to combine different logical operations using two new commands, the & and | operators. The & operator is used when you want to index elements who return true to all the logical operators. The | works as an or operator. Use this when you want to index elements who return true to any of the logical operators. % Index elements who are greater than 2 AND less than 4 a(a > 2 & a < 4) % Index elements who are less than 2 OR greater than 4 a(a < 2 | a > 4)","title":"Logical indexing"},{"location":"matlab-plotting/","text":"Plotting","title":"Plotting"},{"location":"matlab-plotting/#plotting","text":"","title":"Plotting"},{"location":"matlab-tutorial/","text":"Introduction to MATLAB This tutorial serves as a starting point to become familiar with the very basics of MATLAB. This is far from comprehensive introduction, but should serve to teach you enough to get an understanding of key MATLAB principles. If you have no MATLAB experience, it is highly recommended you work through this tutorial prior to trying to use danalyzer tools . Info MATLAB code associated with the meetings that accompanied this tutorial are available on the SAMLAB code wiki here: https://osf.io/jcaq7/files/ The folder matlab_tutorial contains code and a recording of the meetings which may be useful when working through this tutorial.","title":"Introduction to MATLAB"},{"location":"matlab-tutorial/#introduction-to-matlab","text":"This tutorial serves as a starting point to become familiar with the very basics of MATLAB. This is far from comprehensive introduction, but should serve to teach you enough to get an understanding of key MATLAB principles. If you have no MATLAB experience, it is highly recommended you work through this tutorial prior to trying to use danalyzer tools . Info MATLAB code associated with the meetings that accompanied this tutorial are available on the SAMLAB code wiki here: https://osf.io/jcaq7/files/ The folder matlab_tutorial contains code and a recording of the meetings which may be useful when working through this tutorial.","title":"Introduction to MATLAB"},{"location":"matlab-variables/","text":"Variables Variables are how we can store pieces of information in MATLAB. Creating a variable in MATLAB is straightforward. You simply give your variable a name, and assign a value to that variable using the = symbol: myFirstVar = 7 If you type that line into the command window, MATLAB will confirm what you just wrote. Whenever you evaluate some code in MATLAB, it will confirm by printing the result to the command window. This can get annoying after a while, and is often unncessary. You tell MATLAB to shut it by placing a semi colon at the end of the line: myFirstVar = 7; Now that you have created a variable, it appears in the Workspace. It tells you the name of the variable, as well as giving you some information about its content: To get more information about a variable we can use the function whos : % Get information about a specific variable whos myFirstVar % Get information about all variables in the workspace whos This tells us the name of the variable, as well as important information about the size and class of the variable. These bints of info will make more sense as we learn about different types of variable: Name Size Bytes Class Attributes myFirstVar 1x1 8 double You can reassign any value to an existing variable in the exact same way you initially created the variable. To clear a variable from the workspace you can use the clear command. It is also possible to empty a variable, meaning that the variable itself will remain in the workspace but will not have any value assigned to it. Do this using the square brackets [] . We will learn why this is the case in the next section: % Reassign a new value to a variable myFirstVar = 9; % Empty a variable, but keep it in the workspace myFirstVar = []; % Clear the variable from the workspace clear myFirstVar Variable naming There are several rules and guidelines when it comes to naming variables. Here are the key rules: Variable names cannot contain spaces. Use an underscore ( _ ) instead Variable names cannot start with numbers. Variable names cannot contain non-alphanumeric characters except the _ As as well as these hard rules (MATLAB will throw an error), there are also useful guidelines to follow. Others have attempted to write entire \" style guides \", but here are a few help suggestions: Don't use the same name as an existing function. If you do this, your variable will take precedence over the function which is very likely to lead to errors. For instance, if you name a variable mean , it will overwrite the MATLAB function mean . If you are unsure if a variable name might conflict with a function, you can use the which command to check. Use meaningful variables names, but try not to use variable names that are too long. Keeping variables short and meaningful leads to easier to read code. MATLAB is case-sensitive, so pay special attention to to capital letters. myVar, Myvar, and myvar would all be interpreted as different variables by MATLAB. Be consistent. Keep pluralization consistent throughout a script. When you have variables that are 2+ words, separate words consistently e.g. by using snake_case or camelCase. Types of variables We are going to briefly go through the major variable tpyes you are likely to come across while using MATLAB. As you gain more experience it wil lstart to become clearer when to use each type of variable. Numeric variables The most common variable type we will come across. In fact, myFirstVar was a numeric variable. Variables for numbers can contains single numbers (called scalars) or multiple numbers. A one-dimensional matrix of numbers is called an array, and can be created using square brackets [] : anArray = [2 6 8 3]; Tip As well as using square brackets to create arrays/matrices, you can also use square brackets to joing existing variables together. This way of creating a variable is called concatenation : var1 = [1 2 3]; var2 = [4 5 6]; var3 = [var1 var2]; A two-dimensional matrix can be created by using the semi-colon to indicate where the next row begins: aMatrix = [2 6 8 3; 5 2 1 9]; What are the \"dimensions\" of this matrix. We can check by using whos whos aMatrix Name Size Bytes Class Attributes aMatrix 2x4 64 double The size output tells us this a 2x4 matrix. What this tells us is that the first dimension has a size of two, and the second dimension has a size of four. Whenever referring to dimensions of a MATLAB variable, the first dimensions is always referring to rows, and the second dimension columns. As such, we can determine that this matrix has two rows and four columns. While this seems obvious given that we assigned it ourselves, when you are working with much larger datasets you will need ways to quickly figure out a variables dimensions. Question The size of a variable can be found using the size command: size(aMatrix) When you run this code, what does the output mean? An important rule of matrices is that they have to be rectangular. Each row of a matrix must have the same number of elements. The error message Dimensions of arrays being concatenated are not consistenet will be displayed whenever you try to create a variable with differing number of elements. Once you have created some variables, you can use them in mathematical expressions. Most mathematical operations in MATLAB have fairly intuiatve keys: % Create some variables var1 = 6; var2 = 8; % Perform some mathematical operations addVar = var1 + var2; subVar = var1 - var2; mulVar = var1 * var2; divVar = var1 / var2; powVar = var1 ^ 2; You can perform the same operations on arrays and matrics in an element-wise fashion. This means that if you were to add two arrays together, the first element in array 1 would be added to the first element in array 2, and so on. Matrix algebra is an extensive subject in its own right, and you get a primer with MATLAB examples here : % Create some arrays arr1 = [1 2 4]; arr2 = [2 4 6]; % Perform some mathematical operations addArr = arr1 + arr2; subArr = arr1 - arr2; mulArr = arr1 .* arr2; rDivArr = arr1 ./ arr2; % Right array division (divide first array into second) lDivArr = arr1 .\\ arr2; % Left array division (divide second array into first) Logical variables Also called Booleans. These are a sepcial type of variable that can assume either the state true (1) or false (0). We can create a logical variable by using a logical operator. The == sign is just one such case, and evalues whether two elements are equal to each other: % Does 1 = 1? aLogical = 1 == 1; % Does 1 not equal 1? aLogical = 1 ~= 1; % Is 1 greater than 2? aLogical = 1 > 2; % Is 1 less than 2? aLogical = 1 < 2; Hopefully you can figure out which cases the logical value will be true, and which cases the value will be false. You can also create logical variables with the true and false commands: % true trueLogical = true; % false falseLogical = false; A very common usage for logical variables is in if statements, which we will get to in a later section. Although logical variables have their own Class in MATLAB, they can also be treated as numeric variables in operations: aNumeric = 7; aLogical = true; aNumeric + aLogical ans = 8 Character and string variables Characters can be stored as variables using single quotes: % A character array aChar = 'matlab rules'; Unlike a variable name, spaces and non-alphanumeric characters are fine here. MATLAB stores characters according to their ASCII code. As such, adding together a numeric and character will give you unexpected results: num7 = 7; char7 = '7'; num7 + char7 ans = 62 Clearly this is not the answer. Rather than adding 7 to 7, MATLAB is instead adding 55 to 7. This is because the ASCII code for the character '7' is 55. Use the str2num function to automatically convert a character to a number: num7 + str2num('7') ans = 14 More recent versions of MATLAB have introduced a different class of variable, called a string. Functionally, a string array serves a similar purpose to a character array, except they are created using double quotation marks rather than single quotations: % A character array aChar = 'matlab rules'; % A string array aString = \"matlab rules\"; The distinction between a character and a string variable is quite subtle. Let's inspect both variables using whos : whos aChar aString Name Size Bytes Class Attributes aChar 1x12 24 char aString 1x1 166 string This tells us that the character array contains 12 elements, whereas the string array contains just a single element. This illustrates the fundamental difference between a character and string array. In a character array, each letter is an individual element that can be indexed (more on that next). A string array on the other hand contains all of the text inside a single element. In practice, for sleep EEG analysis we will not work too much with these kinds of arrays. However it is important to keep in mind the difference of single and double quotations when creating text-based variables. Cell variables A cell variable allows us to store elements of different types, and can also be useful in storing data of different sizes. We have already seen what happens if we try and create a matrix of different size rows. We also run into problems when we try to store numeric and character variables: [6 'number' 8] ans = '\u0006number\u0006' To deal with this, we use a cell array. You can think of a call array as containing a series of separate cages containing different pieces of information. A cell array can be created using curlu brackets {} : % Create a cell array aCell = {6 'number' 6}; After creating a cell, you can access each element in the cell using indexing, which we will talk about in the next section. Question Cell arrays can also be multidimensional. Try creating a 3 X 5 cell array with a mixture of numbers and characters. Using whos or sizes to verify. Cells can also contains data of different sizes. Remember, in a matrix we cannot have rows with differing numbers of elements. In such a situation, our solution is to place each row of data into a separate \"cage\" inside a cell array: % Won't work as a matrix a = [3 4 5; 5 7 3 1; 1 2]; % Will work in a cell array c = {[3 4 5] [5 7 3 1] [1 2]}; c = 1\u00d73 cell array {1\u00d73 double} {1\u00d74 double} {1\u00d72 double} If we look at the contents of the cell we have just created, we can see our cell array has one cell for each of our differently-lengthed arrays. MATLAB does not throw an error here, because each array is self-contained in its own part of the cell. Structures Structures are another useful way for storing lots of different types of data. They can be thought of as a small database. Each property of a structure is called a field and is defined using thr period key: % Create a structure aStruct.field1 = 3; aStruct.field2 = 'hello'; If you were to inspect the size of this varialbe, you will see it is a 1x1 variable. Although this might be confusing (afterall, we have created 2 fields). The reason for this is that although there are only two fields, there is only one instance of the variable aStruct . We can add a second entry to the variable: % Add a new entry to the structure aStruct(2).field1 = 8; aStruct(2).field2 = 'hello'; As we start working with real data, we are going to come across structures alot. When EEG data is loaded into MATLAB it is stored a structure. Similarily, output from most of the analysis functions (e.g. spindle detection) will be formatted as a structure. As such it is well worth spending some time familiarizing yourself how to access data in a structure. We will discuss ways to access data in a structure in the next section. Tables Tables can be used to stroed data like a spreadsheet, with each column having a title. Like cells and structures, tables can store different data types. The table function creates a table: % Create a table aTable = table(\"ppt_01\", 6.5, 30, 'VariableNames', {'subid', 'spindles', 'memory'}); Here we are first assigning values to each column in the table. This example, which is similar to how you might use a table in real data, is assigning three columns. Column 1 is a string indicating a participant id. Columns 2 and 3 will be numeric data, indicating this participant's spindle density and memory score. After assigning all the data we want, we then need to specify the names of each of our columns. We do this with the input argument 'VariableNames', followed by a cell array specifying our variable headers: aTable = 1\u00d73 table subid spindles memory ________ ________ ______ \"ppt_01\" 6.5 30","title":"Variables"},{"location":"matlab-variables/#variables","text":"Variables are how we can store pieces of information in MATLAB. Creating a variable in MATLAB is straightforward. You simply give your variable a name, and assign a value to that variable using the = symbol: myFirstVar = 7 If you type that line into the command window, MATLAB will confirm what you just wrote. Whenever you evaluate some code in MATLAB, it will confirm by printing the result to the command window. This can get annoying after a while, and is often unncessary. You tell MATLAB to shut it by placing a semi colon at the end of the line: myFirstVar = 7; Now that you have created a variable, it appears in the Workspace. It tells you the name of the variable, as well as giving you some information about its content: To get more information about a variable we can use the function whos : % Get information about a specific variable whos myFirstVar % Get information about all variables in the workspace whos This tells us the name of the variable, as well as important information about the size and class of the variable. These bints of info will make more sense as we learn about different types of variable: Name Size Bytes Class Attributes myFirstVar 1x1 8 double You can reassign any value to an existing variable in the exact same way you initially created the variable. To clear a variable from the workspace you can use the clear command. It is also possible to empty a variable, meaning that the variable itself will remain in the workspace but will not have any value assigned to it. Do this using the square brackets [] . We will learn why this is the case in the next section: % Reassign a new value to a variable myFirstVar = 9; % Empty a variable, but keep it in the workspace myFirstVar = []; % Clear the variable from the workspace clear myFirstVar","title":"Variables"},{"location":"matlab-variables/#variable-naming","text":"There are several rules and guidelines when it comes to naming variables. Here are the key rules: Variable names cannot contain spaces. Use an underscore ( _ ) instead Variable names cannot start with numbers. Variable names cannot contain non-alphanumeric characters except the _ As as well as these hard rules (MATLAB will throw an error), there are also useful guidelines to follow. Others have attempted to write entire \" style guides \", but here are a few help suggestions: Don't use the same name as an existing function. If you do this, your variable will take precedence over the function which is very likely to lead to errors. For instance, if you name a variable mean , it will overwrite the MATLAB function mean . If you are unsure if a variable name might conflict with a function, you can use the which command to check. Use meaningful variables names, but try not to use variable names that are too long. Keeping variables short and meaningful leads to easier to read code. MATLAB is case-sensitive, so pay special attention to to capital letters. myVar, Myvar, and myvar would all be interpreted as different variables by MATLAB. Be consistent. Keep pluralization consistent throughout a script. When you have variables that are 2+ words, separate words consistently e.g. by using snake_case or camelCase.","title":"Variable naming"},{"location":"matlab-variables/#types-of-variables","text":"We are going to briefly go through the major variable tpyes you are likely to come across while using MATLAB. As you gain more experience it wil lstart to become clearer when to use each type of variable.","title":"Types of variables"},{"location":"matlab-variables/#numeric-variables","text":"The most common variable type we will come across. In fact, myFirstVar was a numeric variable. Variables for numbers can contains single numbers (called scalars) or multiple numbers. A one-dimensional matrix of numbers is called an array, and can be created using square brackets [] : anArray = [2 6 8 3]; Tip As well as using square brackets to create arrays/matrices, you can also use square brackets to joing existing variables together. This way of creating a variable is called concatenation : var1 = [1 2 3]; var2 = [4 5 6]; var3 = [var1 var2]; A two-dimensional matrix can be created by using the semi-colon to indicate where the next row begins: aMatrix = [2 6 8 3; 5 2 1 9]; What are the \"dimensions\" of this matrix. We can check by using whos whos aMatrix Name Size Bytes Class Attributes aMatrix 2x4 64 double The size output tells us this a 2x4 matrix. What this tells us is that the first dimension has a size of two, and the second dimension has a size of four. Whenever referring to dimensions of a MATLAB variable, the first dimensions is always referring to rows, and the second dimension columns. As such, we can determine that this matrix has two rows and four columns. While this seems obvious given that we assigned it ourselves, when you are working with much larger datasets you will need ways to quickly figure out a variables dimensions. Question The size of a variable can be found using the size command: size(aMatrix) When you run this code, what does the output mean? An important rule of matrices is that they have to be rectangular. Each row of a matrix must have the same number of elements. The error message Dimensions of arrays being concatenated are not consistenet will be displayed whenever you try to create a variable with differing number of elements. Once you have created some variables, you can use them in mathematical expressions. Most mathematical operations in MATLAB have fairly intuiatve keys: % Create some variables var1 = 6; var2 = 8; % Perform some mathematical operations addVar = var1 + var2; subVar = var1 - var2; mulVar = var1 * var2; divVar = var1 / var2; powVar = var1 ^ 2; You can perform the same operations on arrays and matrics in an element-wise fashion. This means that if you were to add two arrays together, the first element in array 1 would be added to the first element in array 2, and so on. Matrix algebra is an extensive subject in its own right, and you get a primer with MATLAB examples here : % Create some arrays arr1 = [1 2 4]; arr2 = [2 4 6]; % Perform some mathematical operations addArr = arr1 + arr2; subArr = arr1 - arr2; mulArr = arr1 .* arr2; rDivArr = arr1 ./ arr2; % Right array division (divide first array into second) lDivArr = arr1 .\\ arr2; % Left array division (divide second array into first)","title":"Numeric variables"},{"location":"matlab-variables/#logical-variables","text":"Also called Booleans. These are a sepcial type of variable that can assume either the state true (1) or false (0). We can create a logical variable by using a logical operator. The == sign is just one such case, and evalues whether two elements are equal to each other: % Does 1 = 1? aLogical = 1 == 1; % Does 1 not equal 1? aLogical = 1 ~= 1; % Is 1 greater than 2? aLogical = 1 > 2; % Is 1 less than 2? aLogical = 1 < 2; Hopefully you can figure out which cases the logical value will be true, and which cases the value will be false. You can also create logical variables with the true and false commands: % true trueLogical = true; % false falseLogical = false; A very common usage for logical variables is in if statements, which we will get to in a later section. Although logical variables have their own Class in MATLAB, they can also be treated as numeric variables in operations: aNumeric = 7; aLogical = true; aNumeric + aLogical ans = 8","title":"Logical variables"},{"location":"matlab-variables/#character-and-string-variables","text":"Characters can be stored as variables using single quotes: % A character array aChar = 'matlab rules'; Unlike a variable name, spaces and non-alphanumeric characters are fine here. MATLAB stores characters according to their ASCII code. As such, adding together a numeric and character will give you unexpected results: num7 = 7; char7 = '7'; num7 + char7 ans = 62 Clearly this is not the answer. Rather than adding 7 to 7, MATLAB is instead adding 55 to 7. This is because the ASCII code for the character '7' is 55. Use the str2num function to automatically convert a character to a number: num7 + str2num('7') ans = 14 More recent versions of MATLAB have introduced a different class of variable, called a string. Functionally, a string array serves a similar purpose to a character array, except they are created using double quotation marks rather than single quotations: % A character array aChar = 'matlab rules'; % A string array aString = \"matlab rules\"; The distinction between a character and a string variable is quite subtle. Let's inspect both variables using whos : whos aChar aString Name Size Bytes Class Attributes aChar 1x12 24 char aString 1x1 166 string This tells us that the character array contains 12 elements, whereas the string array contains just a single element. This illustrates the fundamental difference between a character and string array. In a character array, each letter is an individual element that can be indexed (more on that next). A string array on the other hand contains all of the text inside a single element. In practice, for sleep EEG analysis we will not work too much with these kinds of arrays. However it is important to keep in mind the difference of single and double quotations when creating text-based variables.","title":"Character and string variables"},{"location":"matlab-variables/#cell-variables","text":"A cell variable allows us to store elements of different types, and can also be useful in storing data of different sizes. We have already seen what happens if we try and create a matrix of different size rows. We also run into problems when we try to store numeric and character variables: [6 'number' 8] ans = '\u0006number\u0006' To deal with this, we use a cell array. You can think of a call array as containing a series of separate cages containing different pieces of information. A cell array can be created using curlu brackets {} : % Create a cell array aCell = {6 'number' 6}; After creating a cell, you can access each element in the cell using indexing, which we will talk about in the next section. Question Cell arrays can also be multidimensional. Try creating a 3 X 5 cell array with a mixture of numbers and characters. Using whos or sizes to verify. Cells can also contains data of different sizes. Remember, in a matrix we cannot have rows with differing numbers of elements. In such a situation, our solution is to place each row of data into a separate \"cage\" inside a cell array: % Won't work as a matrix a = [3 4 5; 5 7 3 1; 1 2]; % Will work in a cell array c = {[3 4 5] [5 7 3 1] [1 2]}; c = 1\u00d73 cell array {1\u00d73 double} {1\u00d74 double} {1\u00d72 double} If we look at the contents of the cell we have just created, we can see our cell array has one cell for each of our differently-lengthed arrays. MATLAB does not throw an error here, because each array is self-contained in its own part of the cell.","title":"Cell variables"},{"location":"matlab-variables/#structures","text":"Structures are another useful way for storing lots of different types of data. They can be thought of as a small database. Each property of a structure is called a field and is defined using thr period key: % Create a structure aStruct.field1 = 3; aStruct.field2 = 'hello'; If you were to inspect the size of this varialbe, you will see it is a 1x1 variable. Although this might be confusing (afterall, we have created 2 fields). The reason for this is that although there are only two fields, there is only one instance of the variable aStruct . We can add a second entry to the variable: % Add a new entry to the structure aStruct(2).field1 = 8; aStruct(2).field2 = 'hello'; As we start working with real data, we are going to come across structures alot. When EEG data is loaded into MATLAB it is stored a structure. Similarily, output from most of the analysis functions (e.g. spindle detection) will be formatted as a structure. As such it is well worth spending some time familiarizing yourself how to access data in a structure. We will discuss ways to access data in a structure in the next section.","title":"Structures"},{"location":"matlab-variables/#tables","text":"Tables can be used to stroed data like a spreadsheet, with each column having a title. Like cells and structures, tables can store different data types. The table function creates a table: % Create a table aTable = table(\"ppt_01\", 6.5, 30, 'VariableNames', {'subid', 'spindles', 'memory'}); Here we are first assigning values to each column in the table. This example, which is similar to how you might use a table in real data, is assigning three columns. Column 1 is a string indicating a participant id. Columns 2 and 3 will be numeric data, indicating this participant's spindle density and memory score. After assigning all the data we want, we then need to specify the names of each of our columns. We do this with the input argument 'VariableNames', followed by a cell array specifying our variable headers: aTable = 1\u00d73 table subid spindles memory ________ ________ ______ \"ppt_01\" 6.5 30","title":"Tables"},{"location":"reference/","text":"Reference This page will contain documentation for all of the functions included as part of danalyzer-tools, and will serve as a reference if you wish to look up information for a particular function.","title":"Reference"},{"location":"reference/#reference","text":"This page will contain documentation for all of the functions included as part of danalyzer-tools, and will serve as a reference if you wish to look up information for a particular function.","title":"Reference"},{"location":"tools-tutorial/","text":"danalyzer tools tutorial This tutorial provides an introduction on how to use MATLAB code to carry out analysis on the sleep EEG signal. This tutorial will mostly be using code avaialble in the danalyzer-tools toolbox, but will also be using some functions from EEGLAB. Make sure you have both installed before beginning.","title":"danalyzer tools tutorial"},{"location":"tools-tutorial/#danalyzer-tools-tutorial","text":"This tutorial provides an introduction on how to use MATLAB code to carry out analysis on the sleep EEG signal. This tutorial will mostly be using code avaialble in the danalyzer-tools toolbox, but will also be using some functions from EEGLAB. Make sure you have both installed before beginning.","title":"danalyzer tools tutorial"},{"location":"vignettes/","text":"Vignettes The purpose of this section is to house little nuggets of code that may be useful when running analysis, but are a bit too niche to fit into the main tutorial.","title":"Vignettes"},{"location":"vignettes/#vignettes","text":"The purpose of this section is to house little nuggets of code that may be useful when running analysis, but are a bit too niche to fit into the main tutorial.","title":"Vignettes"}]}